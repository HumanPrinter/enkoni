<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.VisualStudio.CodeAnalysis.Phoenix</name>
    </assembly>
    <members>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAnalyzer`2">
            <summary>
            Base class for an analyzer that can examine a contract function and produce
            summary info for use by later analysis.
            </summary>
            <typeparam name="TPreconditionSummary">The type of the summary object produced by this analyzer for function call preconditions.</typeparam>
            <typeparam name="TPostconditionSummary">The type of the summary object produced by this analyzer for function postconditions.</typeparam>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAnalyzerBase">
            <summary>
            Base class for an analyzer that can examine a contract function and produce
            summary info for use by later analysis.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAnalyzer`2.#ctor">
            <summary>
            Default constructor for ContractAnalyzer
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAnalyzer`2.SummarizeCallPreconditions(Phx.IR.CallInstruction)">
            <summary>
            Override this method to summarize information known about the program at the point just before a function call.
            </summary>
            <param name="callInstruction">The CallInstruction of the call whose preconditions are to be summarized.</param>
            <returns>An object containing the summary of the call's preconditions.  This may be null.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAnalyzer`2.SummarizeFunctionPostconditions(Phx.FunctionUnit)">
            <summary>
            Override this method to summarize information known about the program at the point just before a function return.
            </summary>
            <param name="functionUnit">The FunctionUnit of the function whose preconditions are to be summarized.</param>
            <returns>An object containing the summary of the function's preconditions.  This may be null.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertion">
            <summary>
            This class serves as a base class for all contract assertion classes.  Contract creators
            attach ContractAssertion objects to label operands that lead to a control flow graph edge
            that, if executed, represents a failed contract.  Rules that fire on contract violations
            examine the set of ContractAssertions on a edge as part of deciding whether or not to fire
            a warning.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertion.#ctor">
            <summary>
            Default constructor for ContractAssertion.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertion.SetContractAssertionsForLabelOperand(Phx.IR.LabelOperand,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertionKind,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertion[])">
            <summary>
            Sets the list of ContractAssertion objects associated with the specified LabelOperand.
            </summary>
            <param name="operand">The label operand whose contract assertions are to be set.</param>
            <param name="kind">Kind of assertion this label represents.</param>
            <param name="contractAssertions">A variable-length list of ContractAssertion objects to be associated with the specified LabelOperand.</param>
            <remarks>This method may only be called once for any given LabelOperand.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertionKind">
            <summary>
            Specifies the kind of contract that an assertion represents.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertionKind.UserDefined">
            <summary>
            The contract assertion is from a user-written assertion within a function body.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertionKind.FunctionPrecondition">
            <summary>
            The contract assertion is a function precondition.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertionKind.FunctionPostcondition">
            <summary>
            The contract assertion is a function postcondition.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertionKind.ClassInvariant">
            <summary>
            The contract assertion is a class invariant.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertionKind.LoopInvariant">
            <summary>
            The contract assertion is a loop invariant.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractInfo">
            <summary>
            Provides information about a contract function.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractInfo.CreateSkeleton(Phx.Symbols.FunctionSymbol,Phx.FunctionUnit)">
            <summary>
            Populate the specified FunctionUnit with IR representing the minimal contract
            for the function.
            </summary>
            <param name="functionSymbol">FunctionSymbol whose contract is to be populated.</param>
            <param name="functionUnit">Contract FunctionUnit to be populated.</param>
            <returns>A ContractInfo object describing the contents of the contract.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractInfo.CallInstruction">
            <summary>
            The CallInstruction that calls the real implementation of the function whose contract
            is being described.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractInfo.FunctionSymbol">
            <summary>
            The symbol for the function whose contract is being described.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractInfo.FunctionUnit">
            <summary>
            The FunctionUnit containing the IR for the contract function.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractInfo.PreconditionLabel">
            <summary>
            The label where any precondition code is to be inserted.  This label
            is after the EnterFunction instruction, before the call instruction.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractInfo.PostconditionLabel">
            <summary>
            The label where any postcondition code is to be inserted.  This label
            is after the call instruction, before the return instruction.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractInfo.ParameterSymbols">
            <summary>
            The list of symbols representing the parameters of the function.  The
            symbols in this list are in the same order as the parameters in the
            function's type.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractInfo.ReturnInstruction">
            <summary>
            The return instruction that returns from the contract.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractInfo.ReturnValueSymbol">
            <summary>
            The symbol representing the return value of the function.  This
            will be null if the function has a void return.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractInfo.UnreachedLabel">
            <summary>
            A label that marks the location of an Unreached instruction.  Contract
            code can branch to this label to denote conditions under which the
            contract is not satisfied.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractService">
            <summary>
            Provides services related to contracts, including function preconditions and postconditions.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractService.RegisterContractAnalyzer``2(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAnalyzer{``0,``1})">
            <summary>
            Register a contract analyzer with the contract service.
            </summary>
            <typeparam name="TPreconditionSummary">The type of object used by the analyzer to summarize the preconditions of a function call.</typeparam>
            <typeparam name="TPostconditionSummary">The type of object used by the analyzer to summarize the postconditions of a function.</typeparam>
            <param name="analyzer">The analyzer to register.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractService.GetPreconditionSummaryForAnalyzer``2(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAnalyzer{``0,``1},Phx.IR.Instruction)">
            <summary>
            Gets the precondition summary object previously computed by the specified analyzer for the specified function.
            </summary>
            <typeparam name="TPreconditionSummary">The type of object used by the analyzer to summarize the preconditions of a function call.</typeparam>
            <typeparam name="TPostconditionSummary">The type of object used by the analyzer to summarize the postconditions of a function.</typeparam>
            <param name="analyzer">The analyzer whose summary information is to be retrieved.</param>
            <param name="enterFunctionInstruction">The EnterFunction instruction of the function being called.</param>
            <returns>The object that summarizes the preconditions for the function.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractService.GetPostconditionSummaryForAnalyzer``2(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAnalyzer{``0,``1},Phx.IR.CallInstruction)">
            <summary>
            Gets the postcondition summary object previously computed by the specified analyzer for the specified function call..
            </summary>
            <typeparam name="TPreconditionSummary">The type of object used by the analyzer to summarize the preconditions of a function call.</typeparam>
            <typeparam name="TPostconditionSummary">The type of object used by the analyzer to summarize the postconditions of a function.</typeparam>
            <param name="analyzer">The analyzer whose summary information is to be retrieved.</param>
            <param name="callInstruction">The CallInstruction of the function being called.</param>
            <returns>The object that summarizes the postconditions for the function call.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.FunctionContractContext">
            <summary>
            Represents the context in which a function contract (a precondition or a postcondition) is being evaluated.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.IObjectWithSourceContext">
            <summary>
            Interface implemented by any object that refers to an entity in source code.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.IObjectWithSourceContext.SourceContext">
            <summary>
            The SourceContext with the location of the object in source code.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.FunctionContractContext.ContractFunctionSymbol">
            <summary>
            The FunctionSymbol of the function whose contract is being evaluated.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.FunctionContractContext.SourceContext">
            <summary>
            The SourceContext representing the point in the source code at which the contract is being evaluated.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.NullPointerContractAssertion">
            <summary>
            This class represents a contract assertion that requires that a particular expression
            of pointer type be null, or that the expression be non-null.
            </summary>
            <remarks>
            The LabelOperand to which the NullPointerContractAssertion is attached must be the operand
            named 'FalseLabel' in an IR sequence as follows:
            
            t123 = Compare(CC) p.up32->void, 0.up32->void
                 = ConditionalBranch(True) t123, TrueLabel, FalseLabel
                 
            The condition code (CC) of the Compare instruction must be either EQ or NE.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.NullPointerContractAssertion.InjectAssertion(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertionKind,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractInfo,Phx.IR.Operand,System.Int32,Phx.IR.Instruction)">
            <summary>
            Inject an assertion that a specified operand is (or is not) equal to null.
            </summary>
            <param name="kind">Kind of assertion to be injected.</param>
            <param name="contractInfo">ContractInfo object describing the contract function unit into which the assertion is to be injected.</param>
            <param name="operand">Operand whose nullness is to be asserted.</param>
            <param name="conditionCode">Condition code specifying how the operand must be compared with null.  This must be either EQ or NE.</param>
            <param name="insertAfterInstruction">Instruction in the contract funciton unit after which to insert the assertion.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.NullPointerContractAssertion.ContainsNullPointerContractAssertion(System.Collections.Generic.IList{Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertion})">
            <summary>
            Determine if a list of ContractAssertion objects contains at least one NullPointerContractAssertion.
            </summary>
            <param name="contractAssertions">The list of ContractAssertion objects to check.</param>
            <returns>'true' if the list contains at least on NullPointerContractAssertion object, 'false' otherwise.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.PostconditionContext">
            <summary>
            Represents the context in which a function postcondition is being evaluated.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.PostconditionContext.SourceContext">
            <summary>
            The SourceContext representing the point in the source code at which the contract is being evaluated.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.PreconditionContext">
            <summary>
            Represents the context in which a function precondition is being evaluated.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.PreconditionContext.CallerFunctionSymbol">
            <summary>
            The FunctionSymbol of the function that is calling the function with the contract.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.PreconditionContext.SourceContext">
            <summary>
            The SourceContext representing the point in the source code at which the contract is being evaluated.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.CopyAnalysisResult">
            <summary>
            Represents the results of a copy analysis on a FunctionUnit.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult">
            <summary>
            Abstract base class that represents the results of an analysis on a FunctionUnit.  Derive from this
            class to define your own kind of analysis result (e.g. NullAnalysisResult).
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult.ComposeWith(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult)">
            <summary>
            Composes the states from two competing analysis models. This method is used to determine the most
            accurate state between analysis results of two different types of analysis trying to determine
            the correct state for the same cell.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult.ConvertTo``1">
            <summary>
            Indicates that this AnalysisResult can also be used to represent another type of analysis result. 
            For example a IntegerRangeAnalysisResult can be converted to a MaxValueIntegerAnalysisResult.
            Returns null if no convertion exists.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.CopyAnalysisResult.ComposeWith(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult)">
            <summary>
            Composes the states from two competing analysis models. This method is used to determine the most
            accurate state between analysis results of two different types of analysis trying to determine
            the correct state for the same cell.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.CopyAnalysisResult.GetRootOperand(Phx.IR.Operand)">
            <summary>
            Determine the root operand from which the specified operand was copied.
            </summary>
            <param name="operand">The operand whose root is to be determined.</param>
            <returns>The root operand from which the input operand was copied.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.DeadAnalysisResult">
            <summary>
            Represents the results of dead code analysis on a FunctionUnit.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.DeadAnalysisResult.ComposeWith(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult)">
            <summary>
            Composes the states from two competing analysis models. This method is used to determine the most
            accurate state between analysis results of two different types of analysis trying to determine
            the correct state for the same cell.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.DeadAnalysisResult.IsEdgeDead(Phx.Graphs.FlowEdge)">
            <summary>
            Determine if the specified flow graph edge is dead.
            </summary>
            <param name="edge">The flow graph edge whose liveness is to be queried.</param>
            <returns>'true' if the specified edge is dead.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.DeadAnalysisResult.IsOperandDead(Phx.IR.Operand)">
            <summary>
            Determine if the specified operand is dead.
            </summary>
            <param name="operand">The operand whose liveness is to be queried.</param>
            <returns>'true' if the specified operand is dead.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.IAnalysisState`1">
            <summary>
            Represents a state object that the StateLattice tracks.
            Implementations of this interface must be public!
            </summary>
            <typeparam name="T">T should be the concrete class that is implementing IAnalysisState.</typeparam>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.IAnalysisState`1.MergeWith(`0)">
            <summary>
            Merges the state of another state when the states from two separate control paths meet.
            For example at a Phi node after an if statement. 
            This method will not change the state of the current state, instead
            it returns an new instance of a merged state.
            (This method is usually simply the union or intersection of two states depending on your lattice).
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.IAnalysisState`1.ComposeWith(`0)">
            <summary>
            Composes the states from two different analysis models. This method is used to take two determine the most
            accurate state between analysis results of two different types of analysis trying to determine
            the correct state for the same cell.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.NullAnalysisResult">
            <summary>
            Represents the results of a null pointer analysis.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.NullAnalysisResult.ComposeWith(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult)">
            <summary>
            Composes the states from two competing analysis models. This method is used to determine the most
            accurate state between analysis results of two different types of analysis trying to determine
            the correct state for the same cell.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.NullAnalysisResult.GetOperandState(Phx.IR.Operand)">
            <summary>
            Get the nullness information for the specified operand.
            </summary>
            <param name="operand">The operand whose state is to be retrieved.</param>
            <returns>A NullState object holding the state of the specified operand.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.ParamArrayAnalysisResult">
            <summary>
            Provides information about the contents of parameter arrays.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.ParamArrayAnalysisResult.GetParamArrayContents(Phx.IR.Operand)">
            <summary>
            Get the contents of a parameter array.
            </summary>
            <param name="operand">The operand used as a param array argument.</param>
            <returns>A list of the operands contained in the parameter array, or null if the contents of the array
            are not available.  An individual operand in the list may be null if no information is known about the
            value of the parameter at that position.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.RangeAnalysisResult">
            <summary>
            Represents the results of a value range analysis.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.RangeAnalysisResult.GetOperandState(Phx.IR.Operand)">
            <summary>
            Get the range of possible values for the specified operand.
            </summary>
            <param name="operand">Operand whose range is to be retrieved.</param>
            <returns>The range of the specified operand.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.RangeAnalysisResult.ComposeWith(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult)">
            <summary>
            Composes the states from two competing analysis models. This method is used to determine the most
            accurate state between analysis results of two different types of analysis trying to determine
            the correct state for the same operand.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.RangeAnalysisResult.Default">
            <summary>
            A RangeAnalysisResult providing a conservative default range for any operand.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.RangeState">
            <summary>
            Represents the range of possible values of a variable.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.RangeState.#ctor(Phx.IR.Operand,Phx.IR.Operand)">
            <summary>
            Creates a new RangeState with the given bounds.
            </summary>
            <param name="minOperand">The minimum possible value</param>
            <param name="maxOperand">The maximum possible value</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.RangeState.#ctor(Phx.Expression.Range)">
            <summary>
            Creates a new RangeState with the given range.
            </summary>
            <param name="range">The range of possible values</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.RangeState.Equals(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.RangeState)">
            <summary>
            Tests if two RangeStates are equal.
            </summary>
            <param name="other">the RangeState to compare against</param>
            <returns>True if and only if the ranges represented by the two states are equal.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.RangeState.Range">
            <summary>
            The range of possible values for the variable this state is associated with.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.ReachableAnalysisResult">
            <summary>
            Represents the results of reachable analysis.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.ReachableAnalysisResult.ComposeWith(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult)">
            <summary>
            Composes the states from two competing analysis models. This method is used to determine the most
            accurate state between analysis results of two different types of analysis trying to determine
            the correct state for the same cell.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.ReachableAnalysisResult.IsEdgeUnreachable(Phx.Graphs.FlowEdge)">
            <summary>
            Determine if the specified flow graph edge is unreachable.
            </summary>
            <param name="edge">The flow graph edge whose reachability is to be queried.</param>
            <returns>'true' if the specified edge is unreachable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.ReachableAnalysisResult.IsBlockUnreachable(Phx.Graphs.BasicBlock)">
            <summary>
            Determine if the specified basic block is unreachable.
            </summary>
            <param name="block">The basic block whose reachability is to be queried.</param>
            <returns>'true' if the specified basic block is unreachable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.ReachableAnalysisResultFromSimulator.IsEdgeUnreachable(Phx.Graphs.FlowEdge)">
            <summary>
            Determine if the specified flow graph edge is unreachable.
            </summary>
            <param name="edge">The flow graph edge whose reachability is to be queried.</param>
            <returns>'true' if the specified edge is unreachable.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.ReachableAnalysisResultFromSimulator.IsBlockUnreachable(Phx.Graphs.BasicBlock)">
            <summary>
            Determine if the specified basic block is unreachable.
            </summary>
            <param name="block">The basic block whose reachability is to be queried.</param>
            <returns>'true' if the specified basic block is unreachable.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedCopyAnalysis">
            <summary>
            Service that provides the results of copy analysis on a FunctionUnit.
            </summary>
            <remarks>
            Copy analysis determines which operands are simple copies of another operand.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.SharedAnalysisService">
            <summary>
            Base class for services that provide analysis results for FunctionUnits.
            </summary>
            <remarks>
            SharedAnalysisService enables a given analysis to be run only once for each
            FunctionUnit, regardless of how many clients are using those results.  The
            analysis is run the first time its results are requested; subsequent requests
            return the same results.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.SharedAnalysisService.#ctor">
            <summary>
            Constructor for SharedAnalysisService.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.SharedAnalysisService.AddResult``1(Phx.FunctionUnit,``0)">
            <summary>
            Add an analysis result for the specified FunctionUnit.
            </summary>
            <typeparam name="TResult">Type of the SharedAnalysisResult object.</typeparam>
            <param name="functionUnit">FunctionUnit whose analysis result is to be set.</param>
            <param name="result">The result object to add.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.SharedAnalysisService.AddResult``2(Phx.FunctionUnit,``1,``0)">
            <summary>
            Add an analysis result for the specified FunctionUnit.
            </summary>
            <typeparam name="TResult">Type of the SharedAnalysisResult object.</typeparam>
            <typeparam name="TSettings">Type of the settings object used to distinguish between different instances of the same analysis with different settings.</typeparam>
            <param name="functionUnit">FunctionUnit whose analysis result is to be set.</param>
            <param name="settings">Object that specifies settings for how this instance of the analysis is to be run.</param>
            <param name="result">The result object to add.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.SharedAnalysisService.GetResultForFunction``1(Phx.FunctionUnit)">
            <summary>
            Get the analysis results for the specified FunctionUnit.
            </summary>
            <typeparam name="TResult">Type of the SharedAnalysisResult object.</typeparam>
            <param name="functionUnit">FunctionUnit whose analysis result is to be retrieved.</param>
            <returns>An object containing the results of the analysis on the specified FunctionUnit, or null if no matching result is found.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.SharedAnalysisService.GetResultForFunction``2(Phx.FunctionUnit,``1)">
            <summary>
            Get the analysis results for the specified FunctionUnit.
            </summary>
            <typeparam name="TResult">Type of the SharedAnalysisResult object.</typeparam>
            <typeparam name="TSettings">Type of the settings object used to distinguish between different instances of the same analysis with different settings.</typeparam>
            <param name="functionUnit">FunctionUnit whose analysis result is to be retrieved.</param>
            <param name="settings">Object that specifies settings for how this instance of the analysis is to be run.</param>
            <returns>An object containing the results of the analysis on the specified FunctionUnit, or null if no matching result is found.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedCopyAnalysis.GetResultForFunction(Phx.FunctionUnit)">
            <summary>
            Get the result of the copy analysis for the specified FunctionUnit.
            </summary>
            <param name="functionUnit">The FunctionUnit whose copy analysis result is to be retrieved.</param>
            <returns>The copy analysis result for the specified FunctionUnit.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.SharedAnalysisResult">
            <summary>
            Base class for result objects to be cached by a SharedAnalysisService.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.SharedAnalysisResult.#ctor">
            <summary>
            Constructor for SharedAnalysisResult.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.SharedAnalysisResult.CleanupAnalysis">
            <summary>
            Override this method to do any necessary cleanup of the analysis result after
            the result is no longer needed.
            </summary>
            <remarks>
            An example of the kind of cleanup typically done by a SharedAnalysisResult would
            be to delete the lattice that was used to compute the analysis results.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedDeadAnalysis">
            <summary>
            Provides the results of dead code analysis on a FunctionUnit.
            </summary>
            <remarks>
            Dead code is code that will be executed, but has no effect
            on the state of the program.  This is different from unreachable
            code, which will not be executed at all.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedDeadAnalysis.GetResultForFunction(Phx.FunctionUnit)">
            <summary>
            Get the results of the dead code analysis for the specified function.
            </summary>
            <param name="functionUnit">FunctionUnit for which the dead code analysis results are to be retrieved.</param>
            <returns>A DeadAnalysisResult object containing the results of the dead code analysis.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedEHAnalysis">
            <summary>
            Service that provides the EH region graph for a FunctionUnit.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedEHAnalysis.GetRegionGraphForFunction(Phx.FunctionUnit)">
            <summary>
            Get the EH region graph for the specified FunctionUnit.
            </summary>
            <param name="functionUnit">The FunctionUnit whose EH region graph is to be retrieved.</param>
            <returns>The EH region graph of the specified FunctionUnit.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedNullAnalysis">
            <summary>
            Service that provides the results of nullness analysis on a FunctionUnit.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedNullAnalysis.GetResultForFunction(Phx.FunctionUnit)">
            <summary>
            Get the results of the nullness analysis for the specified FunctionUnit.
            </summary>
            <param name="functionUnit">FunctionUnit whose nullness analysis result is to be retrieved.</param>
            <returns>The results of the nullness analysis for the specified FunctionUnit.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedNullAnalysis.GetReachabilityResultForFunction(Phx.FunctionUnit)">
            <summary>
            Gets the reachability results from nullness analysis for the specified FunctionUnit.
            </summary>
            <remarks>
            The reachability analysis from nullness anslysis will be able to identify unreachable edges and blocks
            due to nullness comparisons like if(x != null).
            </remarks>
            <param name="functionUnit">FunctionUnit whose reachability result is to be retrieved.</param>
            <returns>The results of the nullness based reachability analysis for the specified FunctionUnit.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedParamArrayAnalysis">
            <summary>
            Service that provides information about the contents of parameter arrays.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedParamArrayAnalysis.GetResultForFunction(Phx.FunctionUnit)">
            <summary>
            Get the results of the parameter array analysis for a specified function.
            </summary>
            <param name="functionUnit">The function for which the results are to be computed.</param>
            <returns>A ParamArrayAnalysisResult object containing the results of the analysis.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedRangeAnalysis">
            <summary>
            Service that provides the results of value range analysis on a FunctionUnit.
            </summary>
            <remarks>
            Value range analysis computes the range of possible values for each operand.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedRangeAnalysis.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ModelService)">
            <summary>
            Creates a new instance of range analysis.
            </summary>
            <param name="modelService">the model service that will provide analysis results to seed the analysis</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedRangeAnalysis.GetResultForFunction(Phx.FunctionUnit)">
            <summary>
            Get the result of the range analysis for the specified FunctionUnit.
            </summary>
            <param name="functionUnit">The FunctionUnit whose range analysis result is to be retrieved.</param>
            <returns>The range analysis result for the specified FunctionUnit.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStateAnalysis`1">
            <summary>
            Abstract shared analysis base class for <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1"/> based lattices.
            </summary>
            <typeparam name="TState">The <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.IAnalysisState`1"/> type that represents the specific state that is being tracked.</typeparam>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStateAnalysis`1.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ModelService)">
            <summary>
            Constructor for <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStateAnalysis`1"/>.
            </summary>
            <param name="modelService">The <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ModelService"/> object that contains the models for this lattice.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStateAnalysis`1.GetResultForFunctionUnit(Phx.FunctionUnit)">
            <summary>
            Gets the <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateAnalysisResult`1"/> from the lattice for the given <see cref="T:Phx.FunctionUnit"/>.
            <para>This method is protected instead of public because rule writers should not need to know about the generic 
            state lattice framework. Types that implement this class should create a "GetResultForFunction" method that 
            wraps a call to this method and returns a wrapper type for the <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateAnalysisResult`1"/> object
            this method returns.
            </para>
            </summary>
            <param name="functionUnit">The <see cref="T:Phx.FunctionUnit"/> to get analysis results for.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStateAnalysis`1.InjectExtraInputAnalysisResults(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet,Phx.FunctionUnit)">
            <summary>
            Allows derived classes to inject extra <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult"/> objects into the input <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet"/>
            that will be passed to the lattice. For example this could be used to let the lattice know about contract information
            specifict to this analysis.
            </summary>
            <param name="latticeResultSet">The <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet"/> where extra <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult"/>s should be added.</param>
            <param name="functionUnit">The <see cref="T:Phx.FunctionUnit"/> being analyzed.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStateAnalysis`1.CreateLattice(Phx.FunctionUnit)">
            <summary>
            <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1"/> is an abstract generic class so <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStateAnalysis`1"/> itself can not 
            create one. Derived types should know the specific kind of lattice they are using and so creating the lattice is left to the 
            derived class.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStringContentsAnalysis">
            <summary>
            Dataflow analysis service that provides string analysis that tracks the possible contents of strings. 
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStringContentsAnalysis.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ModelService,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedNullAnalysis)">
            <summary>
            Constructor for <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStringContentsAnalysis"/>.
            </summary>
            <param name="modelService">The <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ModelService"/> object that contains the models for this lattice.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStringContentsAnalysis.CreateLattice(Phx.FunctionUnit)">
            <summary>
            Creates a <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsLattice"/>.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStringContentsAnalysis.GetResultForFunction(Phx.FunctionUnit)">
            <summary>
            Gets the <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsAnalysisResult"/> for the given <see cref="T:Phx.FunctionUnit"/>.
            This will run the StringContents dataflow analysis over the given function.
            </summary>
            <param name="functionUnit">The <see cref="T:Phx.FunctionUnit"/> to perform StringContents dataflow analysis on.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsAnalysisResult">
            <summary>
            Type that contains the result of a StringContents dataflow analysis.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateAnalysisResult`1">
            <summary>
            Abstract base class for all <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.IAnalysisState`1"/> based <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult"/>s.
            This class is meant for use with a <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1"/>.
            </summary>
            <typeparam name="TState">An <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.IAnalysisState`1"/> type that represents the kind of state being represented by this result.</typeparam>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateAnalysisResult`1.GetOperandState(Phx.IR.Operand)">
            <summary>
            Gets the <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.IAnalysisState`1"/> object for the given <see cref="T:Phx.IR.Operand"/>.
            </summary>
            <param name="operand">The <see cref="T:Phx.IR.Operand"/> to find the state for.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateAnalysisResult`1.ComposeWith(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult)">
            <summary>
            Composes (see <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.IAnalysisState`1.ComposeWith(`0)"/>) this result with another result.
            </summary>
            <param name="otherResult">It is assumed this parameter is really a <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateAnalysisResult`1"/>.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsAnalysisResult.GetOperandState(Phx.IR.Operand)">
            <summary>
            Get the <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState"/> for the given operand. 
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStringValueAnalysis">
            <summary>
            Service providing information about the possible values of strings.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStringValueAnalysis.GetResultForFunction(Phx.FunctionUnit)">
            <summary>
            Get the results of the string value analysis for a specified function.
            </summary>
            <param name="functionUnit">The function for which the results are to be computed.</param>
            <returns>A StringValueAnalysisResult object containing the results of the analysis.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringValueAnalysisResult">
            <summary>
            Base class for analysis results that provide information about the possible values of strings.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringValueAnalysisResult.ComposeWith(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult)">
            <summary>
            Compose this analysis result with another analysis result of the same kind.
            </summary>
            <param name="otherResult">Result with which this result is to be composed.</param>
            <returns>An AnalysisResult representing the composition.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringValueAnalysisResult.TryGetValue(Phx.IR.Operand,System.String@)">
            <summary>
            Get the string value of this operand, if known.
            </summary>
            <param name="operand">The operand whose value is to be retrieved.</param>
            <param name="value">Output parameter to be set to the string value of the operand.</param>
            <returns>'true' if the string value of the operand is known.</returns>
            <remarks>If the string value of the operand is not known, <paramref name="value"/>will be set to null,
            and this method will return 'false'.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedWritableExtentAnalysis">
            <summary>
            Service that provides the results of writable extent analysis on a FunctionUnit.
            </summary>
            <remarks>
            Writable extent analysis determines the range of memory locations to which each
            pointer operand is allowed to write.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedWritableExtentAnalysis.GetResultForFunction(Phx.FunctionUnit)">
            <summary>
            Get the result of the writable extent analysis for the specified FunctionUnit.
            </summary>
            <param name="functionUnit">The FunctionUnit whose writable extent analysis result is to be retrieved.</param>
            <returns>The writable extent analysis result for the specified FunctionUnit.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateCell`1">
            <summary>
            Represents a cell used by the state lattice.
            </summary>
            <remarks>
            IMPORTANT: T must be an immutable type.
            The state lattice makes assumptions that only work if T is immutable.
            </remarks>
            <typeparam name="T">Immutable state type this lattice tracks.</typeparam>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1">
            <summary>
            Abstract base class for all <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.IAnalysisState`1"/> based lattices.
            This class takes care of most of the common code and internal plumbing for lattices. 
            Derived classes should mostly just have to implement the Transfer functions.
            </summary>
            <typeparam name="TState">The type of <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.IAnalysisState`1"/> this state should track.</typeparam>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.#ctor(Phx.FunctionUnit)">
            <summary>
            Constructor for <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1"/>.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.BeginSimulation(Phx.Simulators.Simulator)">
            <summary>
            Method for use by the simulator to initialize the simulation. 
            End users should not be calling this.
            </summary>
            <param name="simulator">The simulator driving the analysis Lattice.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.EndSimulation(Phx.Simulators.Simulator)">
            <summary>
            Method for use only by the simulator to clean up after the simulation.
            End users should not be calling this.
            </summary>
            <param name="simulator">The simulator driving the analysis Lattice.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.PassCheck">
            <summary>
            Called after each iteration of an optimistic simulation to perform internal checking by the Lattice.
            This is a Debug only method.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.GetOperandState(Phx.IR.Operand)">
            <summary>
            Gets the state of the given <see cref="T:Phx.IR.Operand"/>. 
            </summary>
            <param name="operand">A use or definition <see cref="T:Phx.IR.Operand"/>.</param>
            <returns>
            If the lattice never calculated a state for the given <see cref="T:Phx.IR.Operand"/> then the default state is returned.
            This method never returns null.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.Extract(Phx.IR.Operand)">
            <summary>
            Gets the lattice analysis cell for the given <see cref="T:Phx.IR.Operand"/>. 
            End users should not be calling this method, it is meant for internal lattice use.
            </summary>
            <param name="operand">A use or definition <see cref="T:Phx.IR.Operand"/>.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.Merge(Phx.Lattices.Cell,Phx.Lattices.Cell)">
            <summary>
            Merges the states of the two given <see cref="T:Phx.Lattices.Cell"/>s.
            This method will call the <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.IAnalysisState`1.MergeWith(`0)"/> method to merge the states.
            By default this is how analysis results are merged at Phi nodes.
            </summary>
            <param name="workCell">The working <see cref="T:Phx.Lattices.Cell"/> that represents the final state.</param>
            <param name="thisCell">The state to merge into the working state.</param>
            <returns>True iff the given state was merged into the first parameter.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.TransferExternal(Phx.IR.Instruction)">
            <summary>
            Transfer function used to update cells with extra information from the <see cref="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.InputAnalysisResult"/>.
            In most <see cref="M:Phx.Lattices.Lattice.Transfer(Phx.IR.Instruction)"/> implementations this should be the default transfer function if 
            the <see cref="T:Phx.Lattices.Lattice"/> does not have special handling for the given <see cref="T:Phx.IR.Instruction"/>.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.Update(Phx.IR.Operand,`0)">
            <summary>
            Updates the given operand with the given state. 
            Clears the state from the operand if state is null.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.ShouldTrackOperand(Phx.IR.Operand)">
            <summary>
            This method is called when we encounter an operand we haven't attached a cell to yet and 
            we're determining if this lattice should track this operand.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.OnSetInputResult(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet)">
            <summary>
            This method is called when a new <see cref="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.InputResultSet"/> is set. 
            Use this method to extract out extra analysis results.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.InputResultSet">
            <summary>
            Gets and sets the <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet"/> this lattice will use as an input, 
            for example this is used in the <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.TransferExternal(Phx.IR.Instruction)"/> method.
            The setter will also set the value of the <see cref="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.InputAnalysisResult"/> if the 
            input result set contains a result of type <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateAnalysisResult`1"/>.
            To add other processing when the input result set is set see the <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.OnSetInputResult(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet)"/>
            </summary>
            <value>The InputResultSet property will get/set the m_inputResultSet field.</value>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.InputAnalysisResult">
            <summary>
            The input analysis result for the lattice.
            Usually used to pass the result from analysis models to the lattice.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.OutputAnalysisResult">
            <summary>
            Analysis result that contains the result of the lattice analysis.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.DebugControl">
            <summary>
            Debug component control for this Lattice.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1.DefaultResult">
            <summary>
            This method is called whenever we encounter an operand we haven't attached a cell to yet and 
            we don't have a transfer function for the operand's instruction.
            This method will return an imutable StateAnalysisResult that returns the least defined state for operands.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.DefaultStringContentsAnalysisResult">
            <summary>
            <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult"/> that provides a default <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState"/>.
            </summary>
            <remarks>This type has no object state and is a singleton.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.DefaultStringContentsAnalysisResult.GetOperandState(Phx.IR.Operand)">
            <summary>
            Gets the default <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState"/> object for the given <see cref="T:Phx.IR.Operand"/>.
            </summary>
            <param name="operand">The <see cref="T:Phx.IR.Operand"/> to find the state for.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.DefaultStringContentsAnalysisResult.Instance">
            <summary>
            This method will return the only instance of <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.DefaultStringContentsAnalysisResult"/>.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContainsState">
            <summary>
            Represents the literal or nonliteral state of a string operand in a <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState"/>.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContainsState.Maybe">
            <summary>The lattice could not be sure of the state.</summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContainsState.No">
            <summary>The operand does not contain any instances of the specified kind of string.</summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContainsState.Yes">
            <summary>The operand contains at least one instance of the specified kind of string.</summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState">
            <summary>
            Represents all literal strings and string operands that could possibly be contained in a particular string operand.
            </summary>
            <remarks>
            IMPORTANT: This class must remain immutable. The <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StateLattice`1"/> makes assumptions that only work if this class is immutable.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.#ctor">
            <summary>
            Default constructor for <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState"/>.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContainsState,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContainsState)">
            <summary>
            Creates a new <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState"/> with the specified state.
            If the value of the string literal or nonliteral operand is known then 
            one of the more derived constructors should be used.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContainsState,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContainsState,System.String)">
            <summary>
            Constructor that creates a <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState"/> that will include the 
            given string literalValue in its <see cref="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.LiteralValues"/> collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.#ctor(System.String)">
            <summary>
            Constructor that creates a <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState"/> that will include the 
            given string literalValue in its <see cref="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.LiteralValues"/> collection.
            Sets the <see cref="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.LiteralState"/> to Yes and the <see cref="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.NonLiteralState"/> to No.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContainsState,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContainsState,Phx.IR.Operand)">
            <summary>
            Constructor that creates a <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState"/> that will include the 
            given non literal operand in its <see cref="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.NonLiteralOperands"/> collection.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.ContainsLiteralValue(System.String)">
            <summary>
            Queries if the value of the string operand might contain the given string literal.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.ContainsNonLiteralOperand(Phx.IR.Operand)">
            <summary>
            Queries if the value of the string operand might contain the given on literal string operand.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.Equals(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState)">
            <summary>
            Compares string contents tracked by this state and another state.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.MergeWith(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState)">
            <summary>
            Performs the union with this state and the other state 
            and returns a new <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState"/> with the result.
            </summary>
            <seealso cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.IAnalysisState`1.MergeWith(`0)"/>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.ComposeWith(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState)">
            <summary>
            Performs the intersection with this state and the other state
            and returns a new <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState"/> with the result.
            </summary>
            <seealso cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.IAnalysisState`1.ComposeWith(`0)"/>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.ToString">
            <summary>
            Returns a string representation of <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState"/>.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.Default">
            <summary>
            Gets the default StringContentsState object.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.LiteralState">
            <summary>
            Indicates if this string <see cref="T:Phx.IR.Operand"/> contains string literals or not.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.NonLiteralState">
            <summary>
            Indicates if this string <see cref="T:Phx.IR.Operand"/> contains non literal string operands or not.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.LiteralValues">
            <summary>
            Gets a collection of the string literals that could possibly make up the contents of this string <see cref="T:Phx.IR.Operand"/>.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.NonLiteralOperands">
            <summary>
            Gets a collection of the non literal string operands that could possibly make up the contents of this string <see cref="T:Phx.IR.Operand"/>.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.LiteralValuesCount">
            <summary>
            Number of string literals that could possibly make up the contents of this string <see cref="T:Phx.IR.Operand"/>.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringContentsState.NonLiteralOperandsCount">
            <summary>
            Number of non literal string operands that could possibly make up the contents of this string <see cref="T:Phx.IR.Operand"/>.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringValueAnalysisResultComposition.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringValueAnalysisResult,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringValueAnalysisResult)">
            <summary>
            Constructor for StringValueAnalysisResultComposition.
            </summary>
            <param name="result1">The first input result.</param>
            <param name="result2">The second input result.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.StringValueAnalysisResultComposition.TryGetValue(Phx.IR.Operand,System.String@)">
            <summary>
            Get the string value of this operand, if known.
            </summary>
            <param name="operand">The operand whose value is to be retrieved.</param>
            <param name="value">Output parameter to be set to the string value of the operand.</param>
            <returns>'true' if the string value of the operand is known.</returns>
            <remarks>If the string value of the operand is not known, <paramref name="value"/>will be set to null,
            and this method will return 'false'.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.WritableExtentAnalysisResult">
            <summary>
            Represents the results of a writeable extent analysis.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.WritableExtentAnalysisResult.GetOperandState(Phx.IR.Operand)">
            <summary>
            Gets the writeable extent state of the given operand.
            </summary>
            <param name="operand">the operand to be analyzed</param>
            <returns>the writeable extent of the given operand</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.WritableExtentAnalysisResult.ComposeWith(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult)">
            <summary>
            Combines the results of two writeable extent analyses.
            </summary>
            <param name="otherResult">the result of the other writeable extent analysis</param>
            <returns>a new analysis result representing the composition of this result and the parameter</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.DefaultWritableExtentAnalysisResult">
            <summary>
            Provides the best approximation of a writeable extent when no analysis has been performed
            or analysis has yielded no results.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.DefaultWritableExtentAnalysisResult.GetOperandState(Phx.IR.Operand)">
            <summary>
            Gets the conservative writeable extent of the given operand.
            </summary>
            <param name="operand">The operand whose writeable extent is required.</param>
            <returns>A conservative estimate for the writable extent of the operand, or null if the operand is not a buffer.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.DefaultWritableExtentAnalysisResult.Instance">
            <summary>
            Gets the singleton instance of DefaultWritableExtentAnalysisResult.
            </summary>
            <returns>The singleton instance.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.WritableExtentState">
            <summary>
            Represents the writeable extent of a buffer.  Writeable extents are represented
            as the range of valid indeces into that buffer.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.WritableExtentState.#ctor(Phx.IR.Operand,Phx.IR.Operand)">
            <summary>
            Creates a new WriteableExtentState with the given bounds.
            </summary>
            <param name="minOperand">the minimum valid index</param>
            <param name="maxOperand">the maximum valid index</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.WritableExtentState.#ctor(Phx.Expression.Range)">
            <summary>
            Creates a new WriteableExtentState with the given range.
            </summary>
            <param name="range">the range of valid indeces</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.WritableExtentState.MergeWith(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.WritableExtentState)">
            <summary>
            Merge this WritableExtentState with another WritableExtentState.
            </summary>
            <param name="otherState">The other WritableExtentState with which to merge.</param>
            <returns>The merged WritableExtentState.</returns>
            <remarks>The merged range is the intersection of the two input ranges.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.WritableExtentState.ComposeWith(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.WritableExtentState)">
            <summary>
            Compose this WritableExtentState with another WritableExtentState.
            </summary>
            <param name="otherState">The other WritableExtentState with which to compose.</param>
            <returns>The composed WritableExtentState.</returns>
            <remarks>The composed range is the union of the two input ranges.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.WritableExtentState.Equals(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.WritableExtentState)">
            <summary>
            Tests if two WriteableExtentStates are equal.
            </summary>
            <param name="other">the WriteableExtentState to compare against</param>
            <returns>'true' if the ranges represented by the two states are equal.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.WritableExtentState.ToString">
            <summary>
            Convert the WritableExtentState to a string.
            </summary>
            <returns>A string representation of the WritableExtentState.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.WritableExtentState.Range">
            <summary>
            The range of valid indeces into the buffer this state is associated with.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AliasAnalysisPhase.UpdateCallAliasTags(Phx.FunctionUnit)">
            <summary>
            Updates the alias operands on all call instructions based on models.
            </summary>
            <param name="functionUnit">The function whose call instructions are to be updated.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AliasAnalysisPhase.OverlapsWithExistingDestinationOperand(Phx.IR.CallInstruction,System.Int32)">
            <summary>
            Checks if the given alias tag exactly overlaps with an existing destination operand on the callInstruction.
            Multiple destination operands that exactly overlap are not allowed in SSA as it creates an ambiguous definition
            situation where ssa can not determine the correct definiton to hook a use to.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet">
            <summary>
            Represents a set of AnalysisResult objects, providing the ability to select individual
            results based on the type of result.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet.#ctor">
            <summary>
            Construct a new AnalysisResultSet object containing no results.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet)">
            <summary>
            Construct a new AnalysisResultSet object containing the given results.
            </summary>
            <param name="resultSet">AnalysisResultSet to seed the AnalysisResultSet with</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet.AddResult(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResult)">
            <summary>
            Construct a new AnalysisResultSet object containing a single AnalysisResult.
            </summary>
            <param name="result">AnalysisResult object to be added to the AnalysisResultSet.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet.AddResultSet(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet)">
            <summary>
            Add a copy of all of the results in another AnalysisResultSet to this AnalysisResultSet.
            </summary>
            <param name="resultSet">AnalysisResultSet object containing the results to copy.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet.GetResult``1">
            <summary>
            Retrieve a result from the AnalysisResultSet, based on the type of the result.
            </summary>
            <typeparam name="TResult">The type of the result to retrieve.</typeparam>
            <returns>An AnalysisResult object of the specified type, representing all of the results
            of that type that are contained in the AnalysisResultSet, or null if this AnalysisResultSet
            contains no results of the specified type.</returns>
            <remarks>If the AnalysisResultSet contains more than one result of the specified type,
            the AnalysisResult object returned will represent the composition of all of the results
            of the specified type.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CallAliasInfo">
            <summary>
            Specifies the set of memory locations that may be accessed by
            a function call.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CallAliasInfo.#ctor">
            <summary>
            Constructor for CallAliasInfo.  All tag sets are initialized to
            their default value of null.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CallAliasInfo.CompleteModifiedTags">
            <summary>
            A set of alias tags specifying the complete set of memory
            locations that may be written to by this call. If this set
            is null, the function may write to any available memory.
            An empty set indicates that the function does not write
            to any visible memory.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CallAliasInfo.CompleteReferencedTags">
            <summary>
            A set of alias tags specifying the complete set of memory
            locations that may be read from by this call. If this set
            is null, the function may read from any available memory.
            An empty set indicates that the function does not read
            from any visible memory.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CallAliasInfo.SpecificModifiedTags">
            <summary>
            A set of alias tags specifying specific memory locations
            that may be modified by this call. Individual alias operands
            will be inserted for each tag in this set. A null or empty
            set indicates that no individual tags should be inserted.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CallAliasInfo.SpecificReferencedTags">
            <summary>
            A set of alias tags specifying specific memory locations
            that may be read by this call. Individual alias operands
            will be inserted for each tag in this set. A null or empty
            set indicates that no individual tags should be inserted.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost">
            <summary>
            Base class for Phoenix-based code analysis hosts.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.#ctor(Microsoft.VisualStudio.CodeAnalysis.Extensibility.Discovery,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHostFeatures)">
            <summary>
            Constructor for CodeAnalysisHost.
            </summary>
            <param name="discovery">The Discovery object used to provide metadata about the components to be used in the analysis.</param>
            <param name="features">Flags specifying which optional features this host supports.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.Finalize">
            <summary>
            Finalizer for CodeAnalysisHost.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.BuildPasses">
            <summary>
            Builds the list of passes to run.
            </summary>
            <remarks>
            This method will call the virtual methods <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.CreateFunctionPass(Phx.Graphs.CallGraphProcessOrder)"/>,
            <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.CreateModulePass"/>, and <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.CreateContractPass"/>
            to create the necessary passes.  The passes will be created in the order they are to be executed.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.Dispose">
            <summary>
            Frees any resources owned by the host.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.Dispose(System.Boolean)">
            <summary>
            Frees any resources owned by the host.
            </summary>
            <param name="disposing">'true' if this object is being disposed as a result of a call to <see cref="M:System.IDisposable.Dispose"/>.
            'false' if this object is being disposed from a finalizer.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.CreateFunctionPass(Phx.Graphs.CallGraphProcessOrder)">
            <summary>
            Called from within <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.BuildPasses"/> to create a new pass that visits every FunctionUnit in the module.
            </summary>
            <param name="order">Call graph order in which to visit the functions.</param>
            <returns>A phase list that will be executed once for each FunctionUnit in the module, in the order specified by the <paramref name="order"/> parameter.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.CreateContractPass">
            <summary>
            Called from within <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.BuildPasses"/> to create a new pass that visits every contract in the module.
            </summary>
            <returns>A phase list that will be executed once for each contract FunctionUnit in the module.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.CreateModulePass">
            <summary>
            Called from within <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.BuildPasses"/> to create a new pass that visits the module itself.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.StaticInitialize">
            <summary>
            Register Phoenix controls for debugging Phoenix code analysis rules.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.Rules">
            <summary>
            Provides the list of rules to run.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.Models">
            <summary>
            Provides the list of models to run.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHost.Loader">
            <summary>
            Provides the loader used to create instances of components.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHostFeatures">
            <summary>
            Specifies the set of optional features supported by a particular code analysis host object.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHostFeatures.None">
            <summary>
            The host supports no optional features.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.CodeAnalysisHostFeatures.FunctionContracts">
            <summary>
            The host supports function contracts.  The host must override CodeAnalysisHost.CreateContractPass().
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ContractRule">
            <summary>
            Base class for code analysis rules that validate contracts of functions.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule">
            <summary>
            Base class for implementing a Phoenix-based code analysis rule.  Do
            not derive from this class directly.  Instead, derive from one of the
            following classes: <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FunctionBodyRule"/>
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.CreateWarning(Phx.IR.Instruction,System.String)">
            <summary>
            Create a new DiagnosticMessage object to be filled in later with additional information.
            </summary>
            <param name="instruction">Instruction containing the defect.</param>
            <param name="description">Description of the defect.</param>
            <returns>A new DiagnosticMessage object.</returns>
            <remarks>This method does not actually report the warning.  After filling in any additional information,
            the rule should call <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.ReportWarning(Phx.Logging.Diagnostics.DiagnosticMessage)"/> to report the warning.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.GetWarningInfo">
            <summary>
            Get the DiagnosticInfo object representing the warning implemented by this rule object.
            </summary>
            <returns>The DiagnosticInfo object representing the warning implemented by this rule object.</returns>
            <remarks>If this rule object implements more than one rule, this method will fail.  To get a DiagnosticInfo
            object for a specific rule implemented by this rule object, use <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.GetWarningInfo(System.String)"/>.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.GetWarningInfo(System.String)">
            <summary>
            Get the DiagnosticInfo object representing a warning implemented by this rule object.
            </summary>
            <param name="ruleId">Unique identifier of the rule whose DiagnosticInfo is to be retrieved.  This is the same string
            specified as the value of the RuleId property on the BaseRuleAttribute.</param>
            <returns>The DiagnosticInfo object representing the specified warning implemented by this rule object.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.ReportWarning(Phx.Logging.Diagnostics.DiagnosticMessage)">
            <summary>
            Report a warning using a DiagnosticMessage previously created by <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.CreateWarning(Phx.IR.Instruction,System.String)"/>.
            </summary>
            <param name="message">The DiagnosticMessage object containing the information about the warning.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.ReportLocalizedWarning(Phx.IR.Instruction,System.Object[])">
            <summary>
            Report a localized warning on a specific instruction.
            </summary>
            <param name="instruction">Instruction containing the defect.</param>
            <param name="resolutionArguments">Format arguments to substitute into the format string.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.ReportLocalizedWarning(Phx.Symbols.Symbol,System.Object[])">
            <summary>
            Report a localized warning on a specific symbol.
            </summary>
            <param name="symbol">Symbol containing the defect.</param>
            <param name="resolutionArguments">Format arguments to substitute into the format string.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.ReportLocalizedWarning(Phx.Debug.SourceContext,System.Object[])">
            <summary>
            Report a localized warning.
            </summary>
            <param name="sourceContext">SourceContext of the location of the defect.</param>
            <param name="resolutionArguments">Format arguments to substitute into the format string.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.ReportLocalizedWarningWithResolution(Phx.IR.Instruction,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo,System.Object[])">
            <summary>
            Report a localized warning on a specific instruction.
            </summary>
            <param name="instruction">Instruction containing the defect.</param>
            <param name="ruleViolationInfo">Object that provides extra information about this violation.</param>
            <param name="resolutionArguments">Format arguments to substitute into the format string.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.ReportLocalizedWarningWithResolution(Phx.Symbols.Symbol,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo,System.Object[])">
            <summary>
            Report a localized warning on a specific symbol.
            </summary>
            <param name="symbol">Symbol containing the defect.</param>
            <param name="ruleViolationInfo">Object that provides extra information about this violation.</param>
            <param name="resolutionArguments">Format arguments to substitute into the format string.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.ReportLocalizedWarningWithResolution(Phx.Debug.SourceContext,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo,System.Object[])">
            <summary>
            Report a localized warning.
            </summary>
            <param name="sourceContext">SourceContext of the location of the defect.</param>
            <param name="ruleViolationInfo">Object that provides extra information about this violation.</param>
            <param name="resolutionArguments">Format arguments to substitute into the format string.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.ReportWarning(Phx.IR.Instruction,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo,System.String,System.Object[])">
            <summary>
            Report a warning on a specific instruction.
            </summary>
            <param name="instruction">Instruction containing the defect.</param>
            <param name="ruleViolationInfo">Object that provides extra information about this violation.</param>
            <param name="resolutionDescription">Format string for the description of the defect.</param>
            <param name="resolutionArguments">Format arguments to substitute into the resolution description format string.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.ReportWarning(Phx.Symbols.Symbol,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo,System.String,System.Object[])">
            <summary>
            Report a warning on a specific symbol.
            </summary>
            <param name="symbol">Symbol containing the defect.</param>
            <param name="ruleViolationInfo">Object that provides extra information about this violation.</param>
            <param name="resolutionDescription">Format string for the description of the defect.</param>
            <param name="resolutionArguments">Format arguments to substitute into the resolution description format string.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.ReportWarning(Phx.Debug.SourceContext,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo,System.String,System.Object[])">
            <summary>
            Report a warning.
            </summary>
            <param name="sourceContext">SourceContext of the location of the defect.</param>
            <param name="ruleViolationInfo">Object that provides extra information about this violation.</param>
            <param name="resolutionDescription">Format string for the description of the defect.</param>
            <param name="resolutionArguments">Format arguments to substitute into the resolution description format string.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.ReportWarning(Phx.IR.Instruction,System.String,System.Object[])">
            <summary>
            Report a warning on a specific instruction.
            </summary>
            <param name="instruction">Instruction containing the defect.</param>
            <param name="resolutionDescription">Format string for the description of the defect.</param>
            <param name="resolutionArguments">Format arguments to substitute into the resolution description format string.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.ReportWarning(Phx.Symbols.Symbol,System.String,System.Object[])">
            <summary>
            Report a warning on a specific symbol.
            </summary>
            <param name="symbol">Symbol containing the defect.</param>
            <param name="resolutionDescription">Format string for the description of the defect.</param>
            <param name="resolutionArguments">Format arguments to substitute into the resolution description format string.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.ReportWarning(Phx.Debug.SourceContext,System.String,System.Object[])">
            <summary>
            Report a warning.
            </summary>
            <param name="sourceContext">SourceContext of the location of the defect.</param>
            <param name="resolutionDescription">Format string for the description of the defect.</param>
            <param name="resolutionArguments">Format arguments to substitute into the resolution description format string.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.Dispose">
            <summary>
            Frees any resources owned by this rule.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.Dispose(System.Boolean)">
            <summary>
            Frees any resources owned by this rule.
            </summary>
            <param name="disposing">'true' if this object is being disposed as a result of a call to <see cref="M:System.IDisposable.Dispose"/>.
            'false' if this object is being disposed from a finalizer.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRule.StateOfFunction">
            <summary>
            Property that defines if this rule is Dataflow or not.
            By default a rule is Dataflow rule.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ContractRule.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractService)">
            <summary>
            Constructor for ContractRule.
            </summary>
            <param name="contractService">ContractService object on which this rule depends.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ContractRule.CheckPrecondition(Phx.Graphs.FlowEdge,System.Collections.Generic.IList{Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertion},Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.PreconditionContext)">
            <summary>
            Override this method to check a function precondition.
            </summary>
            <param name="edge">Control flow edge that would be executed if the contract assert evaluates to 'false'.</param>
            <param name="contractAssertions">List of contract assertions associated with the edge.</param>
            <param name="context">Context in which the precondition is evaluated.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ContractRule.CheckPostcondition(Phx.Graphs.FlowEdge,System.Collections.Generic.IList{Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractAssertion},Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.PostconditionContext)">
            <summary>
            Override this method to check a function postcondition.
            </summary>
            <param name="edge">Control flow edge that would be executed if the contract assert evaluates to 'false'.</param>
            <param name="contractAssertions">List of contract assertions associated with the edge.</param>
            <param name="context">Context in which the postcondition is evaluated.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FunctionBodyRule">
            <summary>
            Base class for code analysis rules that analyze the implementations of functions.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FunctionBodyRule.#ctor">
            <summary>
            Constructor for FunctionBodyRule.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FunctionBodyRule.AnalyzeFunction(Phx.FunctionUnit)">
            <summary>
            Override this method to implement the analysis of this rule.
            </summary>
            <param name="functionUnit">FunctionUnit to be analyzed.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FunctionCallRule">
            <summary>
            Base class for code analysis rules that analyze calls to functions.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FunctionCallRule.#ctor(System.Boolean)">
            <summary>
            Constructor for FunctionCallRule.
            </summary>
            <param name="doFiltering">Set to 'true' to indicate that the <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FunctionCallRule.ShouldAnalyzeCall(Phx.Symbols.FunctionSymbol)"/> method should be called
            to decide whether or not to analyze calls to a particular function.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FunctionCallRule.AnalyzeCall(Phx.IR.CallInstruction)">
            <summary>
            Override this method to analyze a function call.
            </summary>
            <param name="callInstruction">CallInstruction representing the call to be analyzed.</param>
            <remarks>If filtering is enabled for this rule (see <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FunctionCallRule.#ctor(System.Boolean)"/>), this method will only
            be invoked for calls to FunctionSymbols for which <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FunctionCallRule.ShouldAnalyzeCall(Phx.Symbols.FunctionSymbol)"/> returned 'true'.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FunctionCallRule.ShouldAnalyzeCall(Phx.Symbols.FunctionSymbol)">
            <summary>
            Override this method to decide whether or not to analyze calls to a particular function.
            </summary>
            <param name="functionSymbol">FunctionSymbol for which to filter.</param>
            <returns>'true' if all calls to the specified function should be analyzed, or 'false' if no calls to the specified function
            should be analyzed.</returns>
            <remarks>This function must return the same value every time it is invoked with the same <paramref name="functionSymbol"/> argument.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FxCopRuleAttribute">
            <summary>
            Attribute class that marks a class as implementing a Phoenix-based
            FxCop rule.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FxCopRuleAttribute.#ctor(System.String,System.String,System.Type)">
            <summary>
            Constructor for FxCopRuleAttribute.
            </summary>
            <param name="ruleId">A string uniquely identifying the rule.  This should be a dotted
            name (e.g. "Microsoft.VisualStudio.CA1000"), similar to how
            .NET namespaces and classes are named.</param>
            <param name="name">A string used as the name of the rule when displayed to the user.</param>
            <param name="category">The category type that best classifies this rule.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FxCopRuleInfo">
            <summary>
            Class providing metadata information about a Phoenix-based code analysis rule to be
            run over MSIL code.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRuleInfo">
            <summary>
            Class providing metadata information about a Phoenix-based code analysis rule.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRuleInfo.#ctor(Microsoft.VisualStudio.CodeAnalysis.Extensibility.Discovery,Microsoft.VisualStudio.CodeAnalysis.Extensibility.RuleAttribute,System.Type)">
            <summary>
            Constructor for PhoenixRuleInfo.
            </summary>
            <param name="discovery">Discovery object used to load this rule's metadata.</param>
            <param name="ruleAttribute">The attribute containing the metadata for the rule.</param>
            <param name="implementationType">The type that implements the rule.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRuleInfo.#ctor(Microsoft.VisualStudio.CodeAnalysis.Extensibility.Discovery,Microsoft.VisualStudio.CodeAnalysis.Extensibility.LocalizedRuleAttribute,System.Type)">
            <summary>
            Constructor for PhoenixRuleInfo.
            </summary>
            <param name="discovery">Discovery object used to load this rule's metadata.</param>
            <param name="ruleAttribute">The attribute containing the metadata for the rule.</param>
            <param name="implementationType">The type that implements the rule.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.PhoenixRuleInfo.GetResolutionFormatString(System.String)">
            <summary>
            Gets the localized format string for the specified resolution.
            </summary>
            <param name="resolutionId">The identifier of the resolution.  This must be one of the identifiers in the list returned by the ResolutionIds property.</param>
            <returns>The localized format string for the specified resolution.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FxCopRuleInfo.#ctor(Microsoft.VisualStudio.CodeAnalysis.Extensibility.Discovery,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FxCopRuleAttribute,System.Type)">
            <summary>
            Constructor for FxCopRuleInfo.
            </summary>
            <param name="discovery">Discovery object used to load this rule's metadata.</param>
            <param name="ruleAttribute">The attribute containing the metadata for the rule.</param>
            <param name="implementationType">The type that implements the rule.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FxCopRuleInfo.#ctor(Microsoft.VisualStudio.CodeAnalysis.Extensibility.Discovery,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.LocalizedFxCopRuleAttribute,System.Type)">
            <summary>
            Constructor for FxCopRuleInfo.
            </summary>
            <param name="discovery">Discovery object used to load this rule's metadata.</param>
            <param name="ruleAttribute">The attribute containing the metadata for the rule.</param>
            <param name="implementationType">The type that implements the rule.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FxCopRuleInfo.AnalyzerId">
            <summary>
            The unique identifier of the analyzer that implements the rule.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.LocalizedFxCopRuleAttribute">
            <summary>
            Attribute class that marks a class as implementing a Phoenix-based
            FxCop rule.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.LocalizedFxCopRuleAttribute.#ctor(System.String,System.Type)">
            <summary>
            Constructor for LocalizedFxCopRuleAttribute.
            </summary>
            <param name="ruleId">A string uniquely identifying the rule.  This should be a dotted
            name (e.g. "Microsoft.VisualStudio.CA1000"), similar to how
            .NET namespaces and classes are named.</param>
            <param name="category">The category type that best classifies this rule.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.LocalizedNativeRuleAttribute">
            <summary>
            Attribute class that marks a class as implementing a Phoenix-based
            PREfast rule.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.LocalizedNativeRuleAttribute.#ctor(System.String,System.Type)">
            <summary>
            Constructor for LocalizedNativeRuleAttribute.
            </summary>
            <param name="ruleId">A string uniquely identifying the rule.  This should be a dotted
            name (e.g. "Microsoft.VisualStudio.C6011"), similar to how
            .NET namespaces and classes are named.</param>
            <param name="category">The category type that best classifies this rule.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.Model">
            <summary>
            Base class for implementing a Phoenix-base code analysis model.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.Model.GetAnalysisResultsForFunction(Phx.FunctionUnit,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet)">
            <summary>
            Override this method to provide an AnalysisResultSet modeling the behavior of the callers and callees of a function.
            </summary>
            <param name="functionUnit">FunctionUnit whose callers and callees are to be modeled.</param>
            <param name="inputResults">AnalysisResultSet specifying any information that is already known
            about the behavior of the function.  The model can use this result set to produce more precise
            information about the behavior of the function.</param>
            <returns>An AnalysisResultSet object that models the behavior of the callers and callees of
            <paramref name="functionUnit"/>.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.Model.InstrumentFunction(Phx.FunctionUnit)">
            <summary>
            Override this method to modify the IR of a function to provide additional information about its behavior.
            </summary>
            <param name="functionUnit">FunctionUnit whose IR is to be modified.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.Model.InstrumentContract(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Contracts.ContractInfo)">
            <summary>
            Override this method to modify the IR of a contract function to provide additional preconditions and postconditions.
            </summary>
            <param name="contractInfo">ContractInfo describing the contract function unit.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.Model.GetInferenceOperators(Phx.Graphs.BasicBlock)">
            <summary>
            Override this method to add psi operators to the given block's successor nodes based on 
            something that can be infered in the given block.
            </summary>
            <param name="block">Block to analyze for inference opportunities.</param>
            <returns>Returns a list of InferenceEdgeData objects representing the psi instructions that should be inserted or null.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.Model.GetInferenceExtension``1(Phx.IR.Instruction)">
            <summary>
            Given a Psi instruction, retrive the inference pattern data of type T for that psi instruction.
            </summary>
            <typeparam name="T">Type of an inference pattern's data object.</typeparam>
            <param name="instruction">Psi instruction.</param>
            <returns>Returns the requested inference pattern data object or null if it was not found.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.Model.GetCallAliasInfo(Phx.IR.CallInstruction)">
            <summary>
            Override this method to provide information about what memory locations may be modified
            or referenced by the specified function call.
            </summary>
            <param name="callInstruction">The call instruction whose alias information is to be computed.</param>
            <returns>A CallAliasInfo object specifying the memory locations referenced and modified by
            the function call. If the return value is null, this is equivalent to specifying the default
            values for all tag sets in the CallAliasInfo object.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ModelAttribute">
            <summary>
            Attribute class that marks a class as implementing a Phoenix-based
            code analysis model.  The class to which it is applied must derive
            from <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.Model"/>.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ModelAttribute.#ctor(System.String)">
            <summary>
            Create a new ModelAttribute.
            </summary>
            <param name="modelId">A string uniquely identifying the model.  This should be a dotted
            name (e.g. "Microsoft.VisualStudio.SalModel"), similar to how
            .NET namespaces and classes are named.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ModelAttribute.ModelId">
            <summary>
            A string uniquely identifying the model.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ModelInfo">
            <summary>
            Provides metadata about a code analysis model.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ModelInfo.#ctor(Microsoft.VisualStudio.CodeAnalysis.Extensibility.Discovery,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ModelAttribute,System.Type)">
            <summary>
            Constructor for ModelInfo.
            </summary>
            <param name="discovery">Discovery object that created this ModelInfo.</param>
            <param name="attribute">Attribute instance containing the metadata for the model.</param>
            <param name="implementationType">The type that implements the model.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ModelInfo.ModelId">
            <summary>
            A string uniquely identifying the model.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ModelService">
            <summary>
            Service that provides access to models for the behavior of functions.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.ModelService.GetAnalysisResultsForFunction(Phx.FunctionUnit,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.AnalysisResultSet)">
            <summary>
            Get an AnalysisResultSet that models the behavior of the callers and callees of a
            function.
            </summary>
            <param name="functionUnit">FunctionUnit whose callers and callees are to be modeled.</param>
            <param name="inputResults">AnalysisResultSet specifying any information that is already known
            about the behavior of the function.  The model can use this result set to produce more precise
            information about the behavior of the function.</param>
            <returns>An AnalysisResultSet object that models the behavior of the callers and callees of
            <paramref name="functionUnit"/>.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.NativeRuleAttribute">
            <summary>
            Attribute class that marks a class as implementing a Phoenix-based
            PREfast rule.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.NativeRuleAttribute.#ctor(System.String,System.String,System.Type)">
            <summary>
            Constructor for NativeRuleAttribute.
            </summary>
            <param name="ruleId">A string uniquely identifying the rule.  This should be a dotted
            name (e.g. "Microsoft.VisualStudio.C6011"), similar to how
            .NET namespaces and classes are named.</param>
            <param name="name">A string used as the name of the rule when displayed to the user.</param>
            <param name="category">The category type that best classifies this rule.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.NativeRuleInfo">
            <summary>
            Class providing metadata information about a Phoenix-based code analysis rule to be
            run over C/C++ code.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.NativeRuleInfo.#ctor(Microsoft.VisualStudio.CodeAnalysis.Extensibility.Discovery,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.NativeRuleAttribute,System.Type)">
            <summary>
            Constructor for NativeRuleInfo.
            </summary>
            <param name="discovery">Discovery object used to load this rule's metadata.</param>
            <param name="ruleAttribute">The attribute containing the metadata for the rule.</param>
            <param name="implementationType">The type that implements the rule.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.NativeRuleInfo.#ctor(Microsoft.VisualStudio.CodeAnalysis.Extensibility.Discovery,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.LocalizedNativeRuleAttribute,System.Type)">
            <summary>
            Constructor for NativeRuleInfo.
            </summary>
            <param name="discovery">Discovery object used to load this rule's metadata.</param>
            <param name="ruleAttribute">The attribute containing the metadata for the rule.</param>
            <param name="implementationType">The type that implements the rule.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.NativeRuleInfo.AnalyzerId">
            <summary>
            The unique identifier of the analyzer that implements the rule.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RenameOptimizationPhase.RenameOptimizationWithOperandTracking.ReplaceOneOccurrence(Phx.IR.Operand,Phx.IR.Operand)" -->
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FunctionState">
            <summary>
            This enum differentiates if a given rule needs IR modified after dataflow analysis operations (like rename-optimizations, Ir with PSI node etc.)    
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FunctionState.Dataflow">
            <summary>
            Dataflow type rules will be executed after IR is modified due to dataflow analysis operations (like rename-optimizations, Ir with PSI node etc.)
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.FunctionState.Lexical">
            <summary>
            Lexical type rules will be executed before IR is modified due to dataflow analysis operations (like rename-optimizations, Ir with PSI node etc.)
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo">
            <summary>
            Object that provides extra information about a violation.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo.#ctor(System.String)">
            <param name="resolutionId">ResolutionId of the resolution to be emitted.  This may be null if the specified rule only implements one resolution.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo.GetRelevantLines">
            <summary>
            Returns the 'Lines:' string that should be appended to the end of a violation.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo.ResolutionId">
            <summary>
            ResolutionId of the resolution to be emitted.  This may be null if the specified rule only implements one resolution.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo.RuleId">
            <summary>
            RuleId of the rule reporting the defect.  This may be null if this object only implements one rule.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo.MessageId">
            <summary>
            Unique identifier used to differenciate between violations from the same rule on the same code element.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo.FixCategory">
            <summary>
            Indicates the kind of fix required to fix this violation.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo.MessageLevel">
            <summary>
            Indicates the severity of the violation.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.RuleViolationInfo.RelevantLines">
            <summary>
            Will append a ": Lines:" string followed by a comma separated list of the lines you specified to the end of your 
            resolution and will cause VS to highlight those lines when this violation is selected from the error list.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.StatisticsService">
            <summary>
            Service that allows components to track statistics.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.SymbolRule">
            <summary>
            Base class for code analysis rules that analyze symbols.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.SymbolRule.#ctor">
            <summary>
            Constructor for SymbolRule.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.SymbolRule.AnalyzeSymbol(Phx.Symbols.Symbol)">
            <summary>
            Override this method to analyze a symbol.
            </summary>
            <param name="symbol">The symbol to be analyzed.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.UtilityExtensionAttribute">
            <summary>
            Attribute class that marks a class as implementing a Phoenix-based
            FxCop rule.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.UtilityExtensionInfo.#ctor(Microsoft.VisualStudio.CodeAnalysis.Extensibility.Discovery,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Extensibility.UtilityExtensionAttribute,System.Type)">
            <summary>
            Constructor for UtilityExtensionInfo.
            </summary>
            <param name="discovery">Discovery object used to load this utility's metadata.</param>
            <param name="utilityAttribute">The attribute containing the metadata for the utility.</param>
            <param name="implementationType">The type that implements the utility.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.BranchOnLocalComparePattern">
            <summary>
            Supports inferences on compares of atleast one local variable.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.IChainableInferencePattern">
            <summary>
            An <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.IInferencePattern"/> that is able to make inferences based off of a code pattern that 
            starts with an arbitrary <see cref="T:Phx.IR.Instruction"/>.  This allows other <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.IInferencePattern"/>s
            to extend the code pattern that they are able to infer from by combining the pattern they know how to
            process with the patterns from <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.IChainableInferencePattern"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.IChainableInferencePattern.GetInferenceEdgeDataForBlock(Phx.Graphs.BasicBlock,Phx.IR.Instruction)">
            <summary>
            Gets the <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.InferenceEdgeData"/> for <paramref name="block"/> for the code pattern that 
            starts with <see cref="T:Phx.IR.Instruction"/> <paramref name="patternStart"/>
            </summary>
            <param name="block">
            The <see cref="T:Phx.Graphs.BasicBlock"/> that contains successor edges that this pattern may be able to infer new information on.
            </param>
            <param name="patternStart">
            The <see cref="T:Phx.IR.Instruction"/> that is used to start looking for the code pattern that this <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.IInferencePattern"/> recognizes.
            </param>
            <returns>
            The <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.InferenceEdgeData"/> for all <see cref="T:Phx.IR.Operand"/>, successor <see cref="T:Phx.Graphs.FlowEdge"/> 
            pairs that we can infer new information on.
            </returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.BranchOnLogicalOperatorPattern">
            <summary>
            Looks for two <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.IChainableInferencePattern"/>s connected together by an "And" or an "Or".
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.InferenceUtilities">
            <summary>
            Collection of static helper methods useful for matching inference patterns and other inference related tasks.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.InferenceUtilities.GetBranchPredicateDefinitionInstruction(Phx.Graphs.BasicBlock)">
            <summary>
            Given a basic block, looks for a branch instruction at the end 
            and returns its the instruction that defines its predicate.
            </summary>
            <remarks>
            No need to return the branch condition code because for now we are always assuming the
            condition code for conditional branches is True.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.InferenceUtilities.GetBranchPredicate(Phx.Graphs.BasicBlock)">
            <summary>
            Given a basic block, looks for a branch instruction at the end and returns its predicate.
            </summary>
            <remarks>
            No need to return the branch condition code because for now we are always assuming the
            condition code for conditional branches is True.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.InferenceUtilities.FindDefinitionInstruction(Phx.IR.Operand)">
            <summary>
            Given an operand, trace back to the instruction that defines that operand.
            </summary>
            <remarks>
            Walks back through assignments and conversions.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.InferenceUtilities.IsSafeConversion(Phx.IR.Instruction)">
            <summary>
            Determines if the given convert operand is safe to walk through.
            Safe means that the true or false value of the branch predicate will not be affected 
            by the conversion.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.InferenceUtilities.DefaultGetInferenceEdgeData(Phx.Graphs.BasicBlock,Phx.IR.Operand[])">
            <summary>
            Default method for calculating which psi instructions should be inserted.
            Inserts a Psi instruction for each given source operand on each successor (outgoing) edge from the given block.
            </summary>
            <param name="block">Block where the inference has occured, its outgoing edges will be decorated with Psi instructions.</param>
            <param name="operands">Operands to insert Psi instructions for.</param>
            <remarks>Only use this method if it is safe to infer something about each operand on each possible outgoing edge.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.InferenceUtilities.DefaultGetInferenceEdgeDataForLabelKind(Phx.Graphs.BasicBlock,Phx.IR.LabelOperandKind,Phx.IR.Operand[])">
            <summary>
            Default method for calculating which psi instructions should be inserted on a specific edge.
            Inserts a Psi instruction for each given source operand on the successor (outgoing) edge with the given LabelOperandKind.
            </summary>
            <param name="block">Block where the inference has occured, one of its outgoing edges will be decorated with Psi instructions.</param>
            <param name="labelKind">Indicates which successor (outgoing) edge the psi instruction(s) should be added to.</param>
            <param name="operands">Operands to insert Psi instructions for.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Inference.VirtualMethodCallPattern">
            <summary>
            Insert Psi instructions on the fall-through edge for the this pointer after all callvirt instructions.
            On the fall-through edge, the this pointer is guaranteed to be non-null since the EH edge will be taken
            if the object was null.
            </summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxNodeWrapper.InternalPhxNode">
            <summary>The underlying Phoenix Object this type wraps.</summary>
        </member>
        <member name="M:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.GetDebuggerDisplayTypeArgumentValue">
            <summary>Returns the value of the "Type" named argument on the DebuggerDisplay attribute or null.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.FullName">
            <summary>The full name of the type as it appears in IL (this includes the generic arity).</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.Namespace">
            <summary>The full namespace of the type.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.Template">
            <summary>The generic template definition type for this type instance or null if this type is not generic.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.TemplateArguments">
            <summary>The generic template arguments for a generic type instance.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.TemplateParameters">
            <summary>The generic template parameters for a generic type definition.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.Modifiers">
            <summary>Returns a list of type modifiers for this type or null if this type has no modifiers.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.HasDebuggerDisplayAttribute">
            <summary>Indicates if this this type is marked with the System.Diagnostics.DebuggerDisplayAttribute attribute.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.IsInstantiationOfNullable">
            <summary>Is this type wrapped inside a Nullable type template. 
            For example in the following code snippets "int? data1; int data2;" 
            data1.TypeNode.IsInstantiationOfNullable == true but data2.TypeNode.IsInstantiationOfNullable == false</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.IsVoidType">
            <summary>Is the <see langword="void"/> system type.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.IsObjectType">
            <summary>Is the <see langword="object"/> system type.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.IsValueType">
            <summary>Is System.ValueType or something that derives from it (like an enum or struct).</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.IsEnum">
            <summary>Is an enum type.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.IsDynamicType">
            <summary>
            Is marked as "dynamic" via DynamicAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.DeclaringType">
            <summary>The type of which this node is a member. Null if this node is a member of a Namespace.
            A non null DeclaringType property on a type indicates that the type is a nested type.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.Name">
            <summary>The unqualified name of the member as it appears in IL. 
            Types should just display their name plus their generic arity with no namespace.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.InternalPhxNode">
            <summary>The underlying Phoenix Object this type wraps.</summary>
        </member>
        <member name="T:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeWrapper.PhxNestedGenericTypeInstanceWrapper">
            <summary>
            CCI (which the NameProviders were originally based on) will return an instanciated enclosing (declaring) type when a 
            nested generic instanciation asks. Unfortunately that is not how it works in Reflection or IL, in reality it just uses 
            the template enclosing type and it is possible for there to be no actual instanciation of the enclosing type. 
            This type wraps a template type and gives the appearence of it being instanciated with a type argument.
            </summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxArrayTypeWrapper.ElementType">
            <summary>The type of the elements this array contains.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxArrayTypeWrapper.Sizes">
            <summary>The size of each array dimension (rank).</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxArrayTypeWrapper.LowerBounds">
            <summary>The lower bounds of each array dimension (rank).</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxArrayTypeWrapper.Rank">
            <summary>Gets the rank (number of dimensions) of the Array.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxDelegateWrapper.Parameters">
            <summary>The parameters this delegate type takes.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxEventWrapper.HandlerType">
            <summary>The delegate type that a handler for this event must have. Corresponds to the type clause of C# event declaration.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxEventWrapper.HandlerAdder">
            <summary>The method to be called in order to add a handler to an event. Corresponds to the add clause of a C# event declaration.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxEventWrapper.HandlerRemover">
            <summary>The method to be called in order to remove a handler from an event. Corresponds to the remove clause of a C# event declaration.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxEventWrapper.HandlerCaller">
            <summary>The method that gets called to fire an event. There is no corresponding C# syntax (Does corespond to the Raise VB syntax).</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxEventWrapper.DeclaringType">
            <summary>The type of which this node is a member. Null if this node is a member of a Namespace.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxEventWrapper.Name">
            <summary>The unqualified name of the member as it appears in IL.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxEventWrapper.InternalPhxNode">
            <summary>The underlying Phoenix Object this type wraps.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxFieldWrapper.Type">
            <summary>The type of values that may be stored in the field.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxFieldWrapper.IsStatic">
            <summary>
            Returns whether this field is static or not.
            </summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxFieldWrapper.DeclaringType">
            <summary>The type of which this node is a member. Null if this node is a member of a Namespace.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxFieldWrapper.Name">
            <summary>The unqualified name of the member as it appears in IL.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxFieldWrapper.InternalPhxNode">
            <summary>The underlying Phoenix Object this type wraps.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxLocalWrapper.Name">
            <summary>The name of the local variable. For example the name for "int myLocal;" is "myLocal".</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxLocalWrapper.Type">
            <summary>The type of the local variable.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxLocalWrapper.InternalPhxNode">
            <summary>The underlying Phoenix Object this type wraps.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.DeclaringMember">
            <summary>Provides the declaring event or property of an accessor, null if this method is not an accessor.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.ImplementedInterfaceMethods">
            <summary>Collection of interface methods this method implements.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.Parameters">
            <summary>The parameters this method has to be called with.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.ReturnType">
            <summary>The type of value that this method may return.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.Template">
            <summary>The (generic) method template from which this method was instantiated. Null if this is not a (generic) method template instance.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.TemplateArguments">
            <summary>The arguments used when this (generic) method template instance was instantiated.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.TemplateParameters">
            <summary>The template parameters for this (generic) method template definition.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.CallingConvention">
            <summary>The calling conventions defined for this method. For example VarArgs, C, StandardCall, etc.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.OverriddenMethod">
            <summary>The base class method this method overrides or null if this method does not override any base class methods.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.IsSpecialName">
            <summary>Indicates that this method has a special name. For example operator overloads and constructors have special names.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.IsAccessor">
            <summary>Indicates if this method is an accessor for a property, indexer, or event.
            (For example the get and set methods for a property are considered accessors).</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.IsInstanceConstructor">
            <summary>Indicates if this method is a instance initializer (instance constructor).</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.IsStaticConstructor">
            <summary>Indicates if this method is a static initializer (static constructor).</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.HasExtensionAttribute">
            <summary>Indicates if this method is marked with the System.Runtime.CompilerServices.ExtensionAttribute attribute.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.DeclaringType" -->
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.Name">
            <summary>The unqualified name of the member as it appears in IL. 
            Methods should just display their name with no namespace, parameters, or generic arity.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxMethodWrapper.InternalPhxNode">
            <summary>The underlying Phoenix Object this type wraps.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper" -->
        <member name="M:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.GetDebuggerDisplayTypeArgumentValue">
            <summary>Returns the value of the "Type" named argument on the DebuggerDisplay attribute or null.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.FullName">
            <summary>The full name of the type as it appears in IL (this includes the generic arity).</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.Namespace">
            <summary>The full namespace of the type.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.Template">
            <summary>The generic template definition type for this type instance or null if this type is not generic.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.TemplateArguments">
            <summary>The generic template arguments for a generic type instance.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.TemplateParameters">
            <summary>The generic template parameters for a generic type definition.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.Modifiers">
            <summary>Returns a list of type modifiers for this type or null if this type has no modifiers.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.HasDebuggerDisplayAttribute">
            <summary>Indicates if this this type is marked with the System.Diagnostics.DebuggerDisplayAttribute attribute.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.IsInstantiationOfNullable">
            <summary>Is this type wrapped inside a Nullable type template. 
            For example in the following code snippets "int? data1; int data2;" 
            data1.TypeNode.IsInstantiationOfNullable == true but data2.TypeNode.IsInstantiationOfNullable == false</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.IsVoidType">
            <summary>Is the <see langword="void"/> system type.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.IsObjectType">
            <summary>Is the <see langword="object"/> system type.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.IsValueType">
            <summary>Is System.ValueType or something that derives from it (like an enum or struct).</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.IsEnum">
            <summary>Is an enum type.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.IsDynamicType">
            <summary>
            Is marked as "dynamic" via DynamicAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.DeclaringType">
            <summary>The type of which this node is a member. Null if this node is a member of a Namespace.
            A non null DeclaringType property on a type indicates that the type is a nested type.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxModuleTypeWrapper.Name">
            <summary>The unqualified name of the member as it appears in IL. 
            Types should just display their name plus their generic arity with no namespace.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxParameterWrapper.Name">
            <summary>The name of the parameter. 
            For example the name for "Method(int myParameter)" is "myParameter".</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxParameterWrapper.Type">
            <summary>The type of the parameter.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxParameterWrapper.IsThisParameter">
            <summary>Indicates if this parameter is the this parameter. 
            (As in the this parameter that is present on all instance methods).</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxParameterWrapper.IsParamsArray">
            <summary>Indicates if this parameter is a params array parameter (marked with ParamArrayAttribute). 
            For example in "Method(int x, params string y)" 'y' is a params parameter but 'x' is not.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxParameterWrapper.IsOut">
            <summary>Indicates if this parameter is marked as an Out parameter. 
            For example in "Method(int x, out int y)" 'y' is an out parameter but 'x' is not.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxParameterWrapper.IsIn">
            <summary>Indicates if this parameter is marked as an In parameter (By Value). By default parameters are 
            normally In parameters unless they are marked by by ref or as Out parameters.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxParameterWrapper.ParameterIndex">
            <summary>The parameter index for this parameter (0 indexed).</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxParameterWrapper.DeclaringMethod">
            <summary>The the method this parameter belongs to.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxParameterWrapper.DynamicTypes">
            <summary>
            The set of type elements in the parameter's type that are marked as dynamic.
            </summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxParameterWrapper.InternalPhxNode">
            <summary>The underlying Phoenix Object this type wraps.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxPointerWrapper.ElementType">
            <summary>The type pointed to by this pointer.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxPropertyWrapper.Type">
            <summary>The type of this property (same as the return type of the getter for this property).</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxPropertyWrapper.Getter">
            <summary>The get accessor method (get_[PropertyName]) for this property 
            or null if this property does not have a getter.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxPropertyWrapper.Setter">
            <summary>The set accessor method (set_[PropertyName]) for this property 
            or null if this property does not have a setter.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxPropertyWrapper.Parameters">
            <summary>The extra parameters for this property. 
            For normal properties this will be an empty collection.
            For indexers this will be the indexer parameters.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxPropertyWrapper.IsIndexer">
            <summary> True if this property is an indexer property, false otherwise.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxPropertyWrapper.DeclaringType">
            <summary>The type of which this node is a member.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxPropertyWrapper.Name">
            <summary>The unqualified name of the member as it appears in IL.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxPropertyWrapper.InternalPhxNode">
            <summary>The underlying Phoenix Object this type wraps.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxReferenceWrapper.ElementType">
            <summary>The type refered to by this reference.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxStaticFieldWrapper.Type">
            <summary>The type of values that may be stored in the field.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxStaticFieldWrapper.IsStatic">
            <summary>
            Returns whether this field is static or not.
            </summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxStaticFieldWrapper.DeclaringType">
            <summary>The type of which this node is a member. Null if this node is a member of a Namespace.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxStaticFieldWrapper.Name">
            <summary>The unqualified name of the member as it appears in IL.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxStaticFieldWrapper.InternalPhxNode">
            <summary>The underlying Phoenix Object this type wraps.</summary>
        </member>
        <member name="P:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxTypeModifierWrapper.InternalPhxNode">
            <summary>The underlying Phoenix Object this type wraps.</summary>
        </member>
        <member name="T:Microsoft.FxCop.Engines.Phoenix.INodeWrappers.PhxWrapperFactory">
            <summary>Static factory class that converts Phoenix nodes into INodes used by the NameProviders.</summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Localized">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Localized.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Localized.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.BaseClass">
            <summary>
            Represents a base class subobject within an AggregateType.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject">
            <summary>
            Represents a base class subobject within an AggregateType.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.ToString">
            <summary>
            Returns a string that represents the InheritanceObject.
            </summary>
            <returns>A string description of this InheritanceObject.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.GetOverrideInfo(Phx.Symbols.FunctionSymbol)">
            <summary>
            Gets the information about how the specified introducing virtual function is overridden in this inheritance object.
            </summary>
            <param name="introducingFunction">Symbol of the introducing virtual function whose override information is to be retrieved.</param>
            <returns>An <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideInfo"/> object containing the override information for the specified function.</returns>
            <remarks>
            The function specified by <paramref name="introducingFunction"/> must be introduced by the type of this inheritance object.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.FindInheritanceObjects(Phx.Types.AggregateType)">
            <summary>
            Gets an array of all inheritance objects, including direct and indirect base classes as well as this inheritance object itself, that have the specified type.
            </summary>
            <param name="type">The type of the inheritance objects to find.</param>
            <returns>An array of the InheritanceObject objects of the specified type.  The array will be empty if there are no inheritance objects
            of the specified type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.FindBaseClasses(Phx.Types.AggregateType)">
            <summary>
            Gets an array of all base classes (direct and indirect) of this inheritance object that have the specified type.
            </summary>
            <param name="type">The type of the base classes to find.</param>
            <returns>An array of the BaseClass objects of the specified type.  The array will be empty if there are no base classes
            of the specified type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.FindImmediateBaseClass(Phx.Types.AggregateType)">
            <summary>
            Finds an immediate base class of this object by type.
            </summary>
            <param name="type">The type of the base class to find.</param>
            <returns>The immediate base class whose type matches the specified type, or <see langword="null"/> if no such base class exists.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.FindUniqueBaseClass(Phx.Types.AggregateType)">
            <summary>
            Finds the single base class, direct or indirect, with the specified type.
            </summary>
            <param name="type">The type of the base class to find.</param>
            <returns>The base class with the specified type, or <see langword="null"/> if there is not exactly one base class of the specified type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.FindUniqueInheritanceObject(Phx.Types.AggregateType)">
            <summary>
            Finds the single inheritance object, including direct and indirect base classes as well as this inheritance object itself, with the specified type.
            </summary>
            <param name="type">The type of the inheritance object to find.</param>
            <returns>The inheritance object with the specified type, or <see langword="null"/> if there is not exactly one inheritance object of the specified type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.GetInheritanceObjectInInstantiatedType(Phx.Types.AggregateType)">
            <summary>
            Gets the InheritanceObject in the instantiation of a generic type that corresponds to this inheritance object in the uninstantiated generic type.
            </summary>
            <param name="instantiatedType">Instantiated generic type in which to find the object.</param>
            <returns>The InheritanceObject contained in <paramref name="instantiatedType"/> that corresponds to this InheritanceObject.</returns>
            <remarks>For example, calling this method on the BaseClass for IList&lt;T&gt; in List&lt;T&gt;, passing List&lt;System.Object&gt; as
            <paramref name="instantiatedType"/>, would return IList&lt;System.Object&gt; in List&lt;System.Object&gt;.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.TranslateToDerived(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.BaseClass)">
            <summary>
            Finds the BaseClass object in a derived class that corresponds to this inheritance object.
            </summary>
            <param name="containingInheritanceObjectInDestination">A BaseClass object representing this inheritance object's containing type, contained in the destination type.</param>
            <returns>The BaseClass object in the containing type of <paramref name="containingInheritanceObjectInDestination"/> that corresponds to this inheritance object.</returns>
            <remarks>
            In hierarchies that do not contain multiple non-virtual inheritance, this method is equivalent to calling <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.FindUniqueBaseClass(Phx.Types.AggregateType)"/> on the derived type.
            
            For example, if you had the BaseClass object for System.Object contained in System.IO.Stream, and you wanted to find the corresponding base class for System.Object in
            System.IO.FileStream, you would pass the BaseClass object for System.IO.Stream contained in System.IO.FileStream as the <paramref name="containingInheritanceObjectInDestination"/> parameter.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.GetManagedVtable">
            <summary>
            Gets the entire vtable for the inheritance object.
            Contains all of the virtual methods inherited and introduced by this inheritance object.
            </summary>
            <remarks>
            This method only applies to managed code because it is keyed by FunctionSymbol and 
            in managed code all inheritance is virtual inheritance.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.DumpManagedVtable">
            <summary>
            Dumps the entire vtable for the inheritance object.
            Dumps out all of the virtual methods inherited and introduced by this inheritance object and what their current implementation is.
            </summary>
            <remarks>
            For debugging only.
            This method only applies to managed code because it is keyed by FunctionSymbol and 
            in managed code all inheritance is virtual inheritance.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.Type">
            <summary>
            The type of the inheritance object.
            </summary>
            <remarks>
            For example, for the inheritance object representing the System.Object base class of System.String,
            the Type property would be the type for System.Object.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.ContainingInheritanceObject">
            <summary>
            The SelfInheritanceObject that contains this inheritance object.
            </summary>
            <remarks>
            For example, for the inheritance object representing the System.Object base class of System.String,
            the ContainingInheritanceObject would be the SelfInheritanceObject for System.String.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.ContainingType">
            <summary>
            The type of the class containing this inheritance object.
            </summary>
            <remarks>
            For example, for the inheritance object representing the System.Object base class of System.String,
            the ContainingType property would be the type for System.String.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.BaseClasses">
            <summary>
            List of immediate base classes of this inheritance object.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.IntroducingFunctions">
            <summary>
            List of virtual functions introduced by this inheritance object.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.UninstantiatedInheritanceObject">
            <summary>
            The InheritanceObject in the uninstantiated generic type that corresponds to this inheritance object in an instantiated generic type, or
            <see langword="null"/> if this inheritance object is not contained in an instantiated type.</summary>
            <remarks>For example, the value of this property for IList&lt;System.Object&gt; in List&lt;System.Object&gt; would be
            IList&lt;T&gt; in List&lt;T&gt;.</remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.AllBaseClasses">
            <summary>
            List of all base classes of this inheritance object, both direct and indirect.
            </summary>
            <remarks>
            The base classes are returned in depth-first post-order.  Virtual base classes
            only appear once, in the first position in which they would appear.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.InheritanceHierarchy">
            <summary>
            List of all base classes of this inheritance object, both direct and indirect, plus this inheritance object.
            </summary>
            <remarks>
            The inheritance objects are returned in depth-first post-order.  Virtual base classes
            only appear once, in the first position in which they would appear.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.PrimaryBaseClass">
            <summary>
            The inheritance object for the primary base class of this inheritance object, if any.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.PrimaryBaseClassChain">
            <summary>
            The chain of primary base classes of this inheritance object, starting with this object's
            immediate primary base, and continuing in order to the top-level primary class.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.BaseClass.GetOverrideInfo(Phx.Symbols.FunctionSymbol)">
            <summary>
            Gets the information about how the specified introducing virtual function is overridden in this inheritance object.
            </summary>
            <param name="introducingFunction">Symbol of the introducing virtual function whose override information is to be retrieved.</param>
            <returns>An <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideInfo"/> object containing the override information for the specified function.</returns>
            <remarks>
            The function specified by <paramref name="introducingFunction"/> must be introduced by the type of this inheritance object.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.BaseClass.OverrideFunction(Phx.Symbols.FunctionSymbol,Phx.Symbols.FunctionSymbol,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideOptions)">
            <summary>
            Override the specified function in this inheritance object.
            </summary>
            <param name="introducingFunction">The introducing virtual function to be overridden. This function must be introduced by the type of this InheritanceObject.</param>
            <param name="overridingFunction">The function that provides the implementation with which to override.</param>
            <param name="overridingInheritanceObject">The inheritance object on which the overriding function will be called. The type of this InheritanceObject must be the same
            as the enclosing type of the overriding function.</param>
            <param name="overrideOptions">Flags specifying additional information about the override.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.BaseClass.OverrideFunction(Phx.Symbols.FunctionSymbol,Phx.Symbols.FunctionSymbol,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideOptions)">
            <summary>
            Override the specified function in this inheritance object.
            </summary>
            <param name="introducingFunction">The introducing virtual function to be overridden. This function must be introduced by the type of this InheritanceObject.</param>
            <param name="overridingFunction">The function that provides the implementation with which to override.</param>
            <param name="overrideOptions">Flags specifying additional information about the override.</param>
            <remarks>The enclosing type of the overriding function must appear exactly once in the inheritance hierarchy of the containing type.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.BaseClass.TranslateToBase(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.BaseClass)">
            <summary>
            Finds the InheritanceObject in a base class that corresponds to this inheritance object.
            </summary>
            <param name="containingBaseClassInSource">A BaseClass object representing the base class to translate to, contained in the
            containing type of this base class.</param>
            <returns>The InheritanceObject contained in the type of <paramref name="containingBaseClassInSource"/> that corresponds to this base class.</returns>
            <remarks>
            In hierarchies that do not contain multiple non-virtual inheritance, this method is equivalent to calling <see cref="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject.FindUniqueInheritanceObject(Phx.Types.AggregateType)"/> on the base type.
            
            For example, if you had the BaseClass object for System.Object contained in System.IO.FileStream, and you wanted to find the corresponding base class for System.Object in
            System.IO.Stream, you would pass the BaseClass object for System.IO.Stream contained in System.IO.FileStream as the <paramref name="containingBaseClassInSource"/> parameter.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.BaseClass.ContainingInheritanceObject">
            <summary>
            The SelfInheritanceObject that contains this inheritance object.
            </summary>
            <remarks>
            For example, for the inheritance object representing the System.Object base class of System.String,
            the ContainingInheritanceObject would be the SelfInheritanceObject for System.String.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.BaseClass.InheritanceHierarchy">
            <summary>
            List of all base classes of this base class, both direct and indirect, plus this base class.
            </summary>
            <remarks>
            The base classes are returned in depth-first post-order.  Virtual base classes
            only appear once, in the first position in which they would appear.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.BaseClass.UninstantiatedBaseClass">
            <summary>
            The BaseClass in the uninstantiated generic type that corresponds to this base class in an instantiated generic type, or
            <see langword="null"/> if this base class is not contained in an instantiated type.</summary>
            <remarks>For example, the value of this property for IList&lt;System.Object&gt; in List&lt;System.Object&gt; would be
            IList&lt;T&gt; in List&lt;T&gt;.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.NonVirtualBaseClass">
            <summary>
            An InheritanceObject representing a non-virtual base class.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.NonVirtualBaseClass.DerivedClass">
            <summary>
            The InheritanceObject for the type immediately derived from this base class.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideOptions">
            <summary>
            Flags describing additional information about an override.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideOptions.None">
            <summary>
            No override flags set.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideOptions.Explicit">
            <summary>
            This override occurred explicitly (via a MethodImpl) rather than by matching name and signature.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideOptions.Primary">
            <summary>
            This override is the primary virtual function slot for the overriding function.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.SelfInheritanceObject">
            <summary>
            An InheritanceObject representing the complete object of a type,
            rather than a base class sub-object.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.SelfInheritanceObject.GetOverrideInfo(Phx.Symbols.FunctionSymbol)">
            <summary>
            Gets the information about how the specified introducing virtual function is overridden in this inheritance object.
            </summary>
            <param name="introducingFunction">Symbol of the introducing virtual function whose override information is to be retrieved.</param>
            <returns>An <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideInfo"/> object containing the override information for the specified function.</returns>
            <remarks>
            The function specified by <paramref name="introducingFunction"/> must be introduced by the type of this inheritance object.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.SelfInheritanceObject.ContainingInheritanceObject">
            <summary>
            The SelfInheritanceObject that contains this inheritance object.
            </summary>
            <remarks>
            For example, for the inheritance object representing the System.Object base class of System.String,
            the ContainingInheritanceObject would be the SelfInheritanceObject for System.String.
            </remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.SelfInheritanceObject.UninstantiatedSelfInheritanceObject">
            <summary>
            The SelfInheritanceObject in the uninstantiated generic type that corresponds to this inheritance object in an instantiated generic type, or
            <see langword="null"/> if this inheritance object is not contained in an instantiated type.</summary>
            <remarks>For example, the value of this property for List&lt;System.Object&gt; in List&lt;System.Object&gt; would be
            List&lt;T&gt; in List&lt;T&gt;.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.VirtualBaseClass">
            <summary>
            An InheritanceObject representing a virtual base class.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideInfo">
            <summary>
            Information about how an introducing virtual function is overridden.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideInfo.ToString">
            <summary>
            Returns a string that represents the OverrideInfo.
            </summary>
            <returns>A string description of this OverrideInfo.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideInfo.OverridingFunctionSymbol">
            <summary>
            The function that provides the overriding implementation of the introducing function.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideInfo.OverridingInheritanceObject">
            <summary>
            The inheritance object on which the overriding function will be called.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideInfo.OverrideOptions">
            <summary>
            Flags describing additional information about an override.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.IntroducingFunctionReference">
            <summary>
            Uniquely identifies an introducing virtual function in an inheritance hierarchy.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.IntroducingFunctionReference.#ctor(Phx.Symbols.FunctionSymbol,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.InheritanceObject)">
            <summary>
            Constructor for IntroducingFunctionReference.
            </summary>
            <param name="introducingFunctionSymbol">The introducing virtual function.</param>
            <param name="introducingInheritanceObject">The InheritanceObject that introduces the function.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.IntroducingFunctionReference.ToString">
            <summary>
            Returns a string that represents the IntroducingFunctionReference.
            </summary>
            <returns>A string description of this IntroducingFunctionReference.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.IntroducingFunctionReference.IntroducingFunctionSymbol">
            <summary>
            The introducing virtual function.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.IntroducingFunctionReference.IntroducingInheritanceObject">
            <summary>
            The InheritanceObject that introduces the function.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.IntroducingFunctionReference.OverrideInfo">
            <summary>
            Information about how this introducing virtual function is overridden.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeExtensions">
            <summary>
            Helper methods for the Phx.Types.AggregateType type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeExtensions.FindUniqueBaseClass(Phx.Types.AggregateType,Phx.Types.AggregateType)">
            <summary>
            Finds the single base class, direct or indirect, with the specified type.
            </summary>
            <param name="type">The type on which to find the base class.</param>
            <param name="baseClassType">The type of the base class to find.</param>
            <returns>The base class with the specified type, or <see langword="null"/> if there is not exactly one base class of the specified type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeExtensions.FindUniqueInheritanceObject(Phx.Types.AggregateType,Phx.Types.AggregateType)">
            <summary>
            Finds the single inheritance object, including direct and indirect base classes as well as this inheritance object itself, with the specified type.
            </summary>
            <param name="type">The type on which to find the inheritance object.</param>
            <param name="inheritanceObjectType">The type of the inheritance object to find.</param>
            <returns>The inheritance object with the specified type, or <see langword="null"/> if there is not exactly one inheritance object of the specified type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeExtensions.GetSelfInheritanceObject(Phx.Types.AggregateType)">
            <summary>
            Gets the SelfInheritanceObject for the specified type.
            </summary>
            <param name="aggregateType">The type whose SelfInheritanceObject is to be retrieved.</param>
            <returns>The SelfInheritanceObject for the specified type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeExtensions.GetIntroducingFunctions(Phx.Types.AggregateType)">
            <summary>
            Gets the list of virtual functions introduced by the specified type.
            </summary>
            <param name="aggregateType">The type whose list of introducing functions is to be retrieved.</param>
            <returns>The list of virtual functions introduced by the specified type, or <see langword="null"/> if the type does not
            introduce any virtual functions.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeExtensions.GetOverriddenFunctions(Phx.Types.AggregateType,Phx.Symbols.FunctionSymbol)">
            <summary>
            Gets the list of introducing functions that are overridden by the specified function.
            </summary>
            <param name="aggregateType">The type in which the functions are overridden.</param>
            <param name="functionSymbol">The overriding function.</param>
            <returns>An array of IntroducingFunctionReference objects containing all of the introducing functions that
            <paramref name="functionSymbol"/> overrides in <paramref name="aggregateType"/>.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeExtensions.GetManagedVtable(Phx.Types.AggregateType)">
            <summary>
            Gets the entire vtable for a managed type.
            Contains all of the virtual methods inherited and introduced by this AggregateType.
            </summary>
            <remarks>
            This method only applies to managed code because it is keyed by FunctionSymbol and 
            in managed code all inheritance is virtual inheritance.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeExtensions.GetOverrideHistory(Phx.Types.AggregateType,Phx.Symbols.FunctionSymbol)">
            <summary>
            Gets a collection of all of the base class implementations and definitions of this method.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeExtensions.GetOverrideInfo(Phx.Types.AggregateType,Phx.Symbols.FunctionSymbol)">
            <summary>
            Gets the information about how the specified introducing virtual function is overridden in this type.
            </summary>
            <param name="aggregateType">Type for which the override information is to be retrieved.</param>
            <param name="function">Symbol of the virtual function whose override information is to be retrieved.</param>
            <returns>An <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.OverrideInfo"/> object containing the override information for the specified function.</returns>
            <remarks>
            The returned OverrideInfo object specifies the function that overrides the specified function's primary introducing slot.  
            The specified function's primary introducing slot must be introduced either by the specified type, or by a unique base class of the specified type.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeExtensions.Namespace(Phx.Types.AggregateType)">
            <summary>Returns the name of the Namespace that contains the AggregateType.</summary>
            <param name="aggregateType"></param>
            <returns>Returns the name of the Namespace that contains the AggregateType.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeExtensions.IsCompilerGenerated(Phx.Types.AggregateType)">
            <summary>
            Return true if the specified aggregate type is marked as compiler generated.
            </summary>
            <param name="aggregateType">The aggregate type to test.</param>
            <returns>'true' if <paramref name="aggregateType"/> is compiler generated.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeExtensions.IsDerivedFrom(Phx.Types.AggregateType,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,System.Boolean)">
            <summary>
            Returns true if the given aggregate type is derived from the given type reference.
            </summary>
            <returns>Returns true if the given aggregate type is assignable to the given type reference. Returns false otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeExtensions.IsDerivedFrom(Phx.Types.AggregateType,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>
            Returns true if the given aggregate type is derived from the given type reference.
            </summary>
            <returns>Returns true if the given aggregate type is assignable to the given type reference. Returns false otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeExtensions.IsVisibleOutsideAssembly(Phx.Types.AggregateType)">
            <summary>
            Determine if the specified type is visible outside the assembly that contains it.
            </summary>
            <param name="type">The type to test.</param>
            <returns>'true' if the type can be referenced from another assembly, 'false' otherwise.</returns>
            <remarks>This method returns 'false' for any type that is only visible to a friend assembly.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AllParametersSameMethodSignatureReference">
            <summary>
            Represents a method signature where all the (unknown number of) arguments have the same type.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodSignatureReference">
            <summary>
            Represents a reference to the signature of a CLR method.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodSignatureReference.MatchesFunctionType(Phx.Types.FunctionType)">
            <summary>
            Determine if this method signature reference refers to the specified Phoenix function type.
            </summary>
            <param name="functionType">Phoenix FunctionType to compare to this method signature reference.</param>
            <returns>'true' if this method signature reference refers to the specified FunctionType.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodSignatureReference.AnySignature">
            <summary>
            A MethodSignatureReference that matches any signature.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AllParametersSameMethodSignatureReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>
            Creates an AllParametersSameMethodSignatureReference with the given parameter type.
            </summary>
            <param name="parameterType">The type of all parameters of the method.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AllParametersSameMethodSignatureReference.MatchesFunctionType(Phx.Types.FunctionType)">
            <summary>
            Checks if a particular function type matches this signature.
            </summary>
            <param name="functionType">The function type to check.</param>
            <returns>'true' if and only if all parameters of the give function type match the signature type.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AnyMethodSignatureReference">
            <summary>
            Represents a CLR method signature that will match any signature.
            </summary>
            <remarks>Use this type if you want to match all the overloads of a given method.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AnyMethodSignatureReference.MatchesFunctionType(Phx.Types.FunctionType)">
            <summary>
            Determine if this method signature reference refers to the specified Phoenix function type.
            </summary>
            <param name="functionType">Phoenix FunctionType to compare to this method signature reference.</param>
            <returns>'true' if this method signature reference refers to the specified FunctionType.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AnyMethodSignatureReference.ToString">
            <summary>
            String representation of the MethodSignatureReference.
            </summary>
            <remarks>This is used for debugging only.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AnyTypeReference">
            <summary>
            A reference to any type.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference">
            <summary>
            Represents a reference to a CLR type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.MatchesType(Phx.Types.Type)">
            <summary>
            Determine if this type reference refers to the specified Phoenix type
            </summary>
            <param name="type">Phoenix type to compare to this type reference.</param>
            <returns>'true' if this type reference refers to the specified type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.GetNamedTypePointerReference(System.String)">
            <summary>
            Creates a PointerTypeReference to a NamedTypeReference.
            </summary>
            <param name="typeName">The name of the type, as it appears in metadata (e.g. "System.Object", or "System.Collections.Generic.List`1").</param>
            <returns>PointerTypeReference to a NamedTypeReference</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.Array">
            <summary>
            A reference to System.Array
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.Boolean">
            <summary>
            A reference to System.Boolean.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.Char">
            <summary>
            A reference to System.Char.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.Double">
            <summary>
            A reference to System.Double.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.Int8">
            <summary>
            A reference to System.Int8.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.Int16">
            <summary>
            A reference to System.Int16.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.Int32">
            <summary>
            A reference to System.Int32.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.Int64">
            <summary>
            A reference to System.Int64.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.Object">
            <summary>
            A reference to System.Object.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.ObjectPointer">
            <summary>
            A reference to System.Object^.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.Nullable">
            <summary>
            A reference to System.Nullable&lt;T&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.NullableInstantiation">
            <summary>
            A reference to any instantiation of System.Nullable&lt;T&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.Single">
            <summary>
            A reference to System.Single.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.String">
            <summary>
            A reference to System.String.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.StringPointer">
            <summary>
            A reference to System.String^.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.Type">
            <summary>
            A reference to System.Type.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.TypePointer">
            <summary>
            A reference to System.Type^.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.UInt8">
            <summary>
            A reference to System.UInt8.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.UInt16">
            <summary>
            A reference to System.UInt16.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.UInt32">
            <summary>
            A reference to System.UInt32.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.UInt64">
            <summary>
            A reference to System.UInt64.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.ValueType">
            <summary>
            A reference to System.ValueType.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.Void">
            <summary>
            A reference to System.Void.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.Exception">
            <summary>
            A reference to System.Exception.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.ArgumentException">
            <summary>
            A reference to System.ArgumentException.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.GenericIEnumerable">
            <summary>
            A reference to System.Collections.Generic.IEnumerable`1
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference.VBCompilerServiceConversion">
            <summary>
            A reference to the Microsoft.VisualBasic.CompilerServices.Conversions
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AnyTypeReference.MatchesType(Phx.Types.Type)">
            <summary>
            Determine if this type reference refers to the specified Phoenix type
            </summary>
            <param name="type">Phoenix type to compare to this type reference.</param>
            <returns>Always returns true.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AnyTypeReference.ToString">
            <summary>
            String representation of the TypeReference.
            </summary>
            <remarks>This is used for debugging only.</remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AnyTypeReference.Instance">
            <summary>
            Gets a reference to the AnyTypeReference instance.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfo">
            <summary>
            Provides information about an argument to a function call.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfo.#ctor(Phx.IR.Operand,Phx.Types.Parameter,Phx.Symbols.ParameterSymbol)">
            <summary>
            Constructor for ArgumentInfo.
            </summary>
            <param name="argumentOperand">The operand containing the value of the argument.</param>
            <param name="parameter">The Parameter to which the argument is being passed.</param>
            <param name="parameterSymbol">The ParameterSymbol of the parameter to which the argument is being passed. This may be null.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfo.#ctor(Phx.IR.Operand,Phx.Types.Parameter,Phx.Symbols.ParameterSymbol,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfoOptions)">
            <summary>
            Constructor for ArgumentInfo.
            </summary>
            <param name="argumentOperand">The operand containing the value of the argument.</param>
            <param name="parameter">The Parameter to which the argument is being passed.</param>
            <param name="parameterSymbol">The ParameterSymbol of the parameter to which the argument is being passed. This may be null.</param>
            <param name="options">Additional information about the argument.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfo.#ctor(Phx.IR.ArgumentWithParameter)">
            <summary>
            Constructor for ArgumentInfo.
            </summary>
            <param name="argumentWithParameter">An ArgumentWithParameter describing the argument.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfo.ArgumentOperand">
            <summary>
            The operand containing the value of the argument.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfo.Parameter">
            <summary>
            The Parameter to which the argument is being passed.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfo.ParameterSymbol">
            <summary>
            The ParameterSymbol of the parameter to which the argument is being passed. This may be null.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfo.IsOut">
            <summary>
            Tests whether the argument is passed to an 'out' parameter.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfo.IsRef">
            <summary>
            Tests whether the argument is passed to a 'ref' parameter.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfoOptions">
            <summary>
            Specifies additional information about an argument to a function call.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfoOptions.None">
            <summary>
            No additional information.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfoOptions.IsOut">
            <summary>
            The argument is passed to an 'out' parameter.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfoOptions.IsRef">
            <summary>
            The argument is passed to a 'ref' parameter.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfoOptions.NamedArgument">
            <summary>
            The argument is passed by name.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArrayTypeReference">
            <summary>
            A reference to a CLR array type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArrayTypeReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>
            Create a new ArrayTypeReference.
            </summary>
            <param name="elementType">The element type of the array.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArrayTypeReference.MatchesType(Phx.Types.Type)">
            <summary>
            Determine if this type reference refers to the specified Phoenix type
            </summary>
            <param name="type">Phoenix type to compare to this type reference.</param>
            <returns>'true' if this type reference refers to the specified type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArrayTypeReference.ToString">
            <summary>
            String representation of the TypeReference.
            </summary>
            <remarks>This is used for debugging only.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AttributeArgumentParser">
            <summary>
            Class for reading arguments from the blob of a custom attribute.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AttributeArgumentParser.#ctor(Phx.Symbols.AttributeSymbol)">
            <summary>
            Constructor for AttributeArgumentParser.
            </summary>
            <param name="attribute">The attribute whose blob is to be parsed.</param>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AttributeSymbolExtensions">
            <summary>
            Extension methods for use with Phoenix attribute symbols.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AttributeSymbolExtensions.GetUnnamedArguments``1(Phx.Symbols.AttributeSymbol,``0@)">
            <summary>
            Gets the values of the unnamed arguments of the attribute.
            </summary>
            <typeparam name="TArg1">Type of the first unnamed argument.</typeparam>
            <param name="attribute">The attribute whose arguments are to be read.</param>
            <param name="arg1">The value of the first unnamed argument.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AttributeSymbolExtensions.GetUnnamedArguments``2(Phx.Symbols.AttributeSymbol,``0@,``1@)">
            <summary>
            Gets the values of the unnamed arguments of the attribute.
            </summary>
            <typeparam name="TArg1">Type of the first unnamed argument.</typeparam>
            <typeparam name="TArg2">Type of the second unnamed argument.</typeparam>
            <param name="attribute">The attribute whose arguments are to be read.</param>
            <param name="arg1">The value of the first unnamed argument.</param>
            <param name="arg2">The value of the second unnamed argument.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AttributeSymbolExtensions.GetUnnamedArguments``3(Phx.Symbols.AttributeSymbol,``0@,``1@,``2@)">
            <summary>
            Gets the values of the unnamed arguments of the attribute.
            </summary>
            <typeparam name="TArg1">Type of the first unnamed argument.</typeparam>
            <typeparam name="TArg2">Type of the second unnamed argument.</typeparam>
            <typeparam name="TArg3">Type of the third unnamed argument.</typeparam>
            <param name="attribute">The attribute whose arguments are to be read.</param>
            <param name="arg1">The value of the first unnamed argument.</param>
            <param name="arg2">The value of the second unnamed argument.</param>
            <param name="arg3">The value of the third unnamed argument.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AttributeSymbolExtensions.GetNamedArgument``1(Phx.Symbols.AttributeSymbol,System.String,``0@)">
            <summary>
            Gets the value of the specified named attribute argument.
            </summary>
            <remarks>This method assumes the specified named argument is a property.</remarks>
            <typeparam name="TArg">Type of the named argument.</typeparam>
            <param name="attribute">The attribute whose arguments are to be read.</param>
            <param name="namedArgument">Name of the named argument. (Must be the name of a readable property on the attribute).</param>
            <param name="value">value of the named argument.</param>
            <returns>Returns false if the specified named argument was not specified on the attribute instance. Otherwise returns true.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AttributeSymbolExtensions.GetNamedArguments``1(Phx.Symbols.AttributeSymbol,System.String,System.Boolean,``0@)">
            <summary>
            Gets the value of the specified named attribute argument.
            </summary>
            <typeparam name="TArg">Type of the named argument.</typeparam>
            <param name="attribute">The attribute whose arguments are to be read.</param>
            <param name="namedArgument">Name of the named argument. (Must be the name of a readable property or field on the attribute).</param>
            <param name="namedArgumentIsProperty">True if the specified name is the name of a property, false if it is the name of a field.</param>
            <param name="value">value of the named argument.</param>
            <returns>Returns false if the specified named argument was not specified on the attribute instance. Otherwise returns true.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.BasicBlockExtensions">
            <summary>
            Extension methods for use with Phoenix basic block.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CallInstructionExtensions">
            <summary>
            Extension methods for use with CallInstructions
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CallInstructionExtensions.ResolveOverrideForStaticType(Phx.IR.CallInstruction)">
            <summary>
            Determines the function that would be called if the dynamic type of the instruction's 'this' pointer operand
            were the same as its static type.
            </summary>
            <param name="callInstruction">The call instruction.</param>
            <returns>The function that would be called by this instruction based on the static type of the 'this' pointer operand.</returns>
            <remarks>
            For example:
            <code>
            class A
            {
                public virtual void Foo() { }
            }
            class B : A
            {
                public override void Foo() { }
            }
            class C : B
            {
                public override void Foo() { }
            }
            </code>
            Given a call instruction whose FunctionSymbol property is A.Foo, and whose 'this' pointer argument is of type
            B, ResolveOverrideForStaticType would return the FunctionSymbol for B.Foo, even if the dynamic type of the 'this'
            pointer operand is C.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CallInstructionExtensions.GetAliasOperandForAddressOperand(Phx.IR.CallInstruction,Phx.IR.Operand)">
            <summary>
            Gets the <see cref="T:Phx.IR.AliasOperand"/> that represents the resources that <paramref name="addressOperand"/> points to.
            </summary>
            <param name="callInstruction">
            The <see cref="T:Phx.IR.CallInstruction"/> that takes <paramref name="addressOperand"/> as an argument.
            </param>
            <param name="addressOperand">
            The <see cref="T:Phx.IR.Operand"/> whose <see cref="T:Phx.IR.AliasOperand"/> is desired.  <paramref name="addressOperand"/> must 
            have its IsAddress property set to true.
            </param>
            <returns>The <see cref="T:Phx.IR.AliasOperand"/> that represents the resources that <paramref name="addressOperand"/> points to.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CallInstructionExtensions.GetArgumentWithParameterForArgumentOperand(Phx.IR.CallInstruction,Phx.IR.Operand)">
            <summary>
            Gets the <see cref="T:System.Nullable`1"/> for the argument <see cref="T:Phx.IR.Operand"/> <paramref name="argument"/>.
            </summary>
            <param name="callInstruction">
            The <see cref="T:Phx.IR.CallInstruction"/> that takes <paramref name="argument"/> as an argument.
            </param>
            <param name="argument">
            The <see cref="T:Phx.IR.Operand"/> whose <see cref="T:Phx.IR.ArgumentWithParameter"/> is desired.  <paramref name="argument"/> must be an argument to <paramref name="callInstruction"/>.
            </param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CallKind">
            <summary>
            Specifies the kind of method being called in an expression.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CallKind.Call">
            <summary>
            A normal method call.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CallKind.Property">
            <summary>
            A call to the getter or setter of a non-indexed property.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CallKind.Indexer">
            <summary>
            A call to the getter or setter of an indexed property.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter">
            <summary>
            An expression formatter for rendering Phoenix expressions as C++ source code.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter">
            <summary>
            Base class for all expression formatters.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.IExpressionFormatter">
            <summary>
            Interface to be implemented by any class that will be used to render Phoenix 
            expressions to the user.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.IExpressionFormatter.FormatExpression(Phx.IR.Operand,System.IFormatProvider)">
            <summary>
            Format an expression into a human-readable string resembling source code.
            </summary>
            <param name="expression">The root of the expression tree to format.</param>
            <param name="formatProvider">Provides additional preferences for formatting.</param>
            <returns>The formatted expression.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.IExpressionFormatter.FormatExpression(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.LiteralStringExpression,System.IFormatProvider)">
            <summary>
            Excapes and formats a literal string as it would be in source code.
            </summary>
            <param name="expression">The <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.LiteralStringExpression"/> containing the string to format.</param>
            <param name="formatProvider">Provides additional preferences for formatting.</param>
            <returns>The formatted string literal.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatExpression(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.LiteralStringExpression,System.IFormatProvider)">
            <summary>
            Formats a Phoenix expression for display to the user.
            </summary>
            <param name="expression">The <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.LiteralStringExpression"/> that holds a string to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting the expression.</param>
            <returns>The formatted version of string that <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.LiteralStringExpression"/> holds.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatExpression(Phx.IR.Operand,System.IFormatProvider)">
            <summary>
            Formats a Phoenix expression for display to the user.
            </summary>
            <param name="expression">The Operand that represents the expression to be formatted.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting the expression.</param>
            <returns>The formatted expression.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatExpression(Phx.IR.Operand,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a Phoenix expression for display to the user.
            </summary>
            <param name="expression">The Operand that represents the expression to be formatted.</param>
            <param name="useType">The type <paramref name="expression"/> had when it it was used.</param>
            <param name="definitionType">The original type that <paramref name="expression"/> was defined with.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting the expression.</param>
            <returns>The formatted expression.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatDefinitionInstruction(Phx.IR.Operand,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats the Phoenix expression defined by <paramref name="expression"/>'s definition instruction.
            </summary>
            <param name="expression">The operand whose definition instruction should be formatted.</param>
            <param name="useType">The type <paramref name="expression"/> had when it it was used.</param>
            <param name="definitionType">The original type that <paramref name="expression"/> was defined with.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting the expression.</param>
            <returns>The formatted expression.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatVariableOperand(Phx.IR.VariableOperand,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a VariableOperand.
            </summary>
            <param name="variableOperand">The operand to format.</param>
            <param name="useType">The type <paramref name="variableOperand"/> had when it it was used.</param>
            <param name="definitionType">The original type that <paramref name="variableOperand"/> was defined with.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The name of the variable as a string.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatVariableAddress(Phx.IR.VariableOperand,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a <see cref="T:Phx.IR.VariableOperand"/> that holds the address to a different <see cref="T:Phx.IR.Operand"/>.
            </summary>
            <param name="variableOperand">
            The <see cref="T:Phx.IR.VariableOperand"/> to format.  IsAddress must be true on <paramref name="variableOperand"/>.
            </param>
            <param name="useType">The type <paramref name="variableOperand"/> had when it it was used.</param>
            <param name="definitionType">The original type that <paramref name="variableOperand"/> was defined with.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted string of the operand that <paramref name="variableOperand"/> contains the address of.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatMemoryOperand(Phx.IR.MemoryOperand,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a MemoryOperand.
            </summary>
            <param name="memoryOperand">The memory operand to format.</param>
            <param name="useType">The type <paramref name="memoryOperand"/> had when it it was used.</param>
            <param name="definitionType">The original type that <paramref name="memoryOperand"/> was defined with.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The MemoryOperand formatted as a field, array, or pointer access.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatFunctionOperand(Phx.IR.FunctionOperand,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a <see cref="T:Phx.IR.FunctionOperand"/>.
            </summary>
            <param name="functionOperand">The <see cref="T:Phx.IR.FunctionOperand"/> to format.</param>
            <param name="useType">The type <paramref name="functionOperand"/> had when it it was used.</param>
            <param name="definitionType">The original type that <paramref name="functionOperand"/> was defined with.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted string representation of <paramref name="functionOperand"/>.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatCall(Phx.IR.CallInstruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a method call.
            </summary>
            <param name="callInstruction">The call to format.</param>
            <param name="useType">The type that the destination of <paramref name="callInstruction"/> had when it it was used.</param>
            <param name="definitionType">The type that <paramref name="callInstruction"/> results in.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted method call.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatArguments(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CallKind,System.Collections.Generic.IList{Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfo},System.IFormatProvider)">
            <summary>
            Formats the argument list to a method call.
            </summary>
            <param name="callKind">The kind of method call.</param>
            <param name="arguments">The arguments to the call.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted argument list.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatArguments(Phx.IR.CallInstruction,System.IFormatProvider)">
            <summary>
            Formats the argument list to a method call.
            </summary>
            <param name="callInstruction">The instruction containing the method call.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted argument list.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatArgument(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfo,System.IFormatProvider)">
            <summary>
            Formats a single argument of a <see cref="T:Phx.IR.CallInstruction"/>.
            </summary>
            <param name="argumentInfo">
            The <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfo"/> containing the <see cref="T:Phx.IR.Operand"/> and <see cref="T:Phx.Types.Parameter"/> information to format.
            </param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted argument.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatArrayContents(Phx.IR.Operand,System.String,System.IFormatProvider)">
            <summary>
            Formats the contents of an array if they are known.  This function is called to format params arrays.
            </summary>
            <param name="operand">The array whose contents will be formatted.</param>
            <param name="argumentSeparator">The string to insert between each array element.</param>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> to use in formatting the expression.</param>
            <returns>The formatted argument.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatStringConcat(Phx.IR.CallInstruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a call to String.Concat.
            </summary>
            <param name="callInstruction">The instruction containing the call to String.Concat.</param>
            <param name="useType">The type that the destination of <paramref name="callInstruction"/> had when it it was used.</param>
            <param name="definitionType">The type that <paramref name="callInstruction"/> results in.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted call to String.Concat</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatStringArrayConcat(Phx.IR.CallInstruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a call to String.Concat(string[]).
            </summary>
            <param name="callInstruction">The instruction containing the call to String.Concat(string[]).</param>
            <param name="useType">The type that the destination of <paramref name="callInstruction"/> had when it it was used.</param>
            <param name="definitionType">The type that <paramref name="callInstruction"/> results in.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted call to String.Concat(string[]).</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatArrayAccess(Phx.IR.CallInstruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a call to System.Array.Get.
            </summary>
            <param name="callInstruction">The instruction that contains the call to System.Array.Get</param>
            <param name="useType">The type that the destination of <paramref name="callInstruction"/> had when it it was used.</param>
            <param name="definitionType">The resulting element type of the array.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted call to System.Array.Get.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatStaticPrefix(Phx.IR.CallInstruction,Phx.Types.Type,System.IFormatProvider)">
            <summary>
            Formats the portion of a static function call that exists before the function name.  For example, in a call to
            "String.Format", FormatStaticPrefix is responsible for outputting "String."
            </summary>
            <param name="callInstruction">The instruction that contains the method call to format.</param>
            <param name="useType">The type <paramref name="callInstruction"/> had when it it was used.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The prefix to the static function call in <paramref name="callInstruction"/>.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatInstancePrefix(Phx.IR.CallInstruction,Phx.Types.Type,System.IFormatProvider)">
            <summary>
            Formats the portion of an instance function call that exists before the function name.  For example, in a call
            to "myString.Format", FormatInstancePrefix is responsible for printing out "myString."
            </summary>
            <param name="callInstruction">The instruction that contains the method call to format.</param>
            <param name="useType">The type that the destination of <paramref name="callInstruction"/> had when it it was used.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The prefix to the static function call in <paramref name="callInstruction"/>.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatNewObj(Phx.IR.CallInstruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a newobj instruction.
            </summary>
            <param name="instruction">The newobj instruction to format.</param>
            <param name="useType">The type that the destination of <paramref name="callInstruction"/> had when it it was used.</param>
            <param name="definitionType">The original type that <paramref name="callInstruction"/> was defined with.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The string represenation of the newobj instruction.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.IsDelegateInvoke(Phx.Symbols.FunctionSymbol)">
            <summary>
            Returns true if this is the function symbol for a System.Delegate.Invoke method.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatDelegateInvoke(Phx.IR.CallInstruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a call to System.Delegate.Invoke
            </summary>
            <param name="callInstruction">The instruction that contains the call to System.Delegate.Invoke</param>
            <param name="useType">The type that the destination of <paramref name="callInstruction"/> had when it it was used.</param>
            <param name="definitionType">The resulting element type of the call.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted call to System.Delegate.Invoke.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatIsInst(Phx.IR.Instruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats an isinst instruction.
            </summary>
            <param name="instruction">The isinst instruction to format.</param>
            <param name="useType">The type that the variable argument to IsInst had when it it was used.</param>
            <param name="definitionType">The original type that the variable argument to IsInst was defined with.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the instruction.</param>
            <returns>The string representation of the isinst instruction.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatCast(Phx.IR.Operand,Phx.Types.Type,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a cast from one type to another as a C-style cast.
            </summary>
            <param name="variableToCast">The variable that is being cast.</param>
            <param name="targetType">The type the variable is being cast to.</param>
            <param name="useType">The type that the variable argument to the cast had when it it was used.</param>
            <param name="definitionType">The original type that that the variable argument to the cast was defined with.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the instruction.</param>
            <returns>
            "([type])[var]" where [type] is the destination type, and [var] is the variable being cast.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatConversionOperator(Phx.IR.CallInstruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a conversion from one type to another.
            </summary>
            <param name="callInstruction">The instruction that contains the convert operation.</param>
            <param name="useType">The type that the variable argument to the conversion had when it it was used.</param>
            <param name="definitionType">The original type that that the variable argument to the conversion was defined with.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the instruction.</param>
            <returns>The formatted type conversion.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatImmediate(Phx.IR.ImmediateOperand,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats an immediate operand.
            </summary>
            <param name="immediateOperand">The operand for format for output.</param>
            <param name="useType">The type <paramref name="immediateOperand"/> had when it was used.</param>
            <param name="definitionType">The original type that <paramref name="immediateOperand"/> was defined with.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted immediate.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatDefaultValue(Phx.Types.Type,System.IFormatProvider)">
            <summary>
            Formats the default value of the specified type.
            </summary>
            <param name="type">Type whose default value is to be formatted.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted default value expression.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatIntLiteral(System.Int64,Phx.Types.Type,System.IFormatProvider)">
            <summary>
            Formats an integer literal.
            </summary>
            <param name="value">The value to format.</param>
            <param name="type">The type of the literal.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>The string representation of the integer.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatFloatLiteral(System.Double,Phx.Types.Type,System.IFormatProvider)">
            <summary>
            Formats a floating point literal.
            </summary>
            <param name="value">The value to format.</param>
            <param name="type">The type of the literal.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>The string representation of the float.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatBooleanLiteral(System.Boolean,System.IFormatProvider)">
            <summary>
            Formats a Boolean literal.
            </summary>
            <param name="value">The value to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>The string representation of the Boolean.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatCharacterLiteral(System.Char,System.IFormatProvider)">
            <summary>
            Formats a character literal.
            </summary>
            <param name="value">The value to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>The string represenation of the character.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.EscapeCharacterLiteral(System.Char,System.IFormatProvider)">
            <summary>
            Formats a character literal.
            </summary>
            <param name="ch">The character to format</param>
            <param name="formatProvider">The IFormatProvider to use when formatting.</param>
            <returns>The escaped string representation of the character.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatStringImmediate(Phx.IR.ImmediateOperand,System.IFormatProvider)">
            <summary>
            Formats a string immediate.
            </summary>
            <param name="immediateOperand">The immediate to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>The string representation of the string.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatStringLiteral(System.String,System.IFormatProvider)">
            <summary>
            Formats a string literal.
            </summary>
            <param name="literal">The literal to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>The escaped and formatted version of <paramref name="literal"/>.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatDefaultValueOfValueType(Phx.Types.AggregateType,System.IFormatProvider)">
            <summary>
            Format the default value of a value type.
            </summary>
            <param name="aggregateType">The value type to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>A string representation of the default value of the value type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatDefaultValueOfTypeVariable(Phx.Types.TypeVariableType,System.IFormatProvider)">
            <summary>
            Format the default value of a type variable type.
            </summary>
            <param name="type">The type variable type to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>A string representation of the default value of the type variable type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatAdd(Phx.IR.Instruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats an add <see cref="T:Phx.IR.Instruction"/>.
            </summary>
            <param name="definitionInstruction">The <see cref="T:Phx.IR.Instruction"/> containing the addition expression.</param>
            <param name="useType">The type the destination of the add instruction had when it it was used.</param>
            <param name="definitionType">The resulting type of this expression.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted add <see cref="T:Phx.IR.Instruction"/>.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatPointerAddition(Phx.IR.Operand,Phx.IR.Operand,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a pointer addition <see cref="T:Phx.IR.Instruction"/>.
            </summary>
            <param name="pointer">The pointer argument to the add instruction.</param>
            <param name="operand">The non-pointer argument to the add instruction.</param>
            <param name="useType">The type the destination of the add instruction had when it it was used.</param>
            <param name="definitionType">The resulting type of this expression.</param>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> to use in formatting the expression.</param>
            <returns>The formatted pointer addition <see cref="T:Phx.IR.Instruction"/>.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatUnaryOperator(Phx.IR.Operand,Phx.Types.Type,Phx.Types.Type@,System.String,System.IFormatProvider)">
            <summary>
            Formats a unary expression.
            </summary>
            <param name="sourceOperand">The source operand of the expression.</param>
            <param name="useType">The type the result of the expression had when it was used.</param>
            <param name="definitionType">The resulting type of this expression.</param>
            <param name="formatString">The string representation of the formatted instruction.</param>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> to use in formatting the expression.</param>
            <returns>The formatted expression.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatUnaryOperator(Phx.IR.Instruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider,System.String)">
            <summary>
            Formats an instruction that takes one argument and produces one explicit result.
            </summary>
            <param name="definitionInstruction">The <see cref="T:Phx.IR.Instruction"/> to format.</param>
            <param name="useType">The type the destination of the instruction had when it was used.</param>
            <param name="definitionType">The resulting type of this expression.</param>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> to use in formatting the expression.</param>
            <param name="formatString">The string representation of the formatted instruction.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatBinaryOperator(Phx.IR.Operand,Phx.IR.Operand,System.String,System.IFormatProvider)">
            <summary>
            Formats a binary expression.
            </summary>
            <param name="firstSourceOperand">The first source operand of the expression.</param>
            <param name="secondSourceOperand">The second source operand of the expression.</param>
            <param name="formatString">The string representation of the formatted instruction.</param>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> to use in formatting the expression.</param>
            <returns>The formatted expression.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatBinaryOperator(Phx.IR.Instruction,Phx.Types.Type@,System.IFormatProvider,System.String)">
            <summary>
            Formats an instruction that has takes two arguments and results in one explicit result.
            </summary>
            <param name="definitionInstruction">The <see cref="T:Phx.IR.Instruction"/> to format.</param>
            
            <param name="definitionType">The resulting type of this expression.</param>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> to use in formatting the expression.</param>
            <param name="formatString">The string representation of the formatted instruction.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatArrayLength(Phx.IR.Instruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a LdLen instruction as an access to the Length property of an array.
            </summary>
            <param name="instruction">The <see cref="T:Phx.IR.Instruction"/> to format.</param>
            <param name="useType">The type the destination of the instruction had when it was used.</param>
            <param name="definitionType">The resulting type of this expression.</param>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> to use in formatting the expression.</param>
            <returns>The string representation of the formatted instruction.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatNewArray(Phx.IR.Instruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a NewArray instruction as an array constructor call.
            </summary>
            <param name="instruction">The <see cref="T:Phx.IR.Instruction"/> to format.</param>
            <param name="useType">The type the destination of the instruction had when it was used.</param>
            <param name="definitionType">The resulting type of this expression.</param>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> to use in formatting the expression.</param>
            <returns>The string representation of the formatted instruction.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.FormatNewManagedArray(Phx.IR.CallInstruction,Phx.Types.ManagedArrayType,System.IFormatProvider)">
            <summary>
            Formats a NewObj instruction with a managed array type as an array constructor call.
            </summary>
            <param name="callInstruction">The <see cref="T:Phx.IR.Instruction"/> to format.</param>
            <param name="arrayType">The type of the array being created.</param>
            <param name="formatProvider">An <see cref="T:System.IFormatProvider"/> to use in formatting the expression.</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.GetNewArrayString(System.IFormatProvider,System.String,System.Int32,System.String)" -->
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.GetDisplayName(Microsoft.VisualStudio.CodeAnalysis.AnalysisResults.Keyword)">
            <summary>
            Gets the display name for the specified <see cref="T:Microsoft.VisualStudio.CodeAnalysis.AnalysisResults.Keyword"/>
            </summary>
            <param name="keyword">The keyword to get the display name for.</param>
            <returns>The display name of <paramref name="keyword"/></returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.GetDisplayName(Phx.ExtensibleObject)">
            <summary>
            Gets the display name for the specified <see cref="T:Phx.ExtensibleObject"/>
            </summary>
            <param name="node">The Phoenix object to get the display name for.</param>
            <returns><paramref name="node"/>'s display name.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.SharedCopyAnalysis">
            <summary>
            Shared copy analysis object for use by this expression formatter.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.SharedParamArrayAnalysis">
            <summary>
            Shared param array analysis object for use by this expression formatter.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.ArrayPrefix">
            <summary>
            Gets the string to use for prefixing an array.  "[" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.ArraySuffix">
            <summary>
            Gets the string to use for suffixing an array.  "]" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.BitwiseOrOperator">
            <summary>
            Gets the string to use to represent a bitwise OR operation.  "|" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.ClassSeparator">
            <summary>
            Gets the string to use for seperating the namespace name from the class name, 
            or the class name from a static method name.  "::" in C++.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.PointerAccess">
            <summary>
            Gets the string to use for seperating the class name from an instance method name
            when accessed through a pointer.  "->" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.ReferenceAccess">
            <summary>
            Gets the string to use for seperating the class name from an instance method name
            when accessed through a reference.  "." in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.ManagedPointerDefinitionSymbol">
            <summary>
            Gets the string to use for declaring a managed pointer.  "^" in C++.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatter.StringConcatOperator">
            <summary>
            Gets the string to use to represent a string concatenation operation.  "+" in C#.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.GetDisplayName(Microsoft.VisualStudio.CodeAnalysis.AnalysisResults.Keyword)">
            <summary>
            Gets the display name for the specified <see cref="T:Microsoft.VisualStudio.CodeAnalysis.AnalysisResults.Keyword"/>
            </summary>
            <param name="keyword">The keyword to get the display name for.</param>
            <returns>The display name of <paramref name="keyword"/></returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.GetDisplayName(Phx.ExtensibleObject)">
            <summary>
            Gets the display name for the specified <see cref="T:Phx.ExtensibleObject"/>
            </summary>
            <param name="node">The Phoenix object to get the display name for.</param>
            <returns><paramref name="node"/>'s display name.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedParamArrayAnalysis,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedCopyAnalysis)">
            <summary>
            Primary constructor for a CPlusPlusExpressionFormatter.
            </summary>
            <param name="paramArrayAnalysis">SharedParamArrayAnalysis to use for extracting individual arguments from a parameters array.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.FormatIntLiteral(System.Int64,Phx.Types.Type,System.IFormatProvider)">
            <summary>
            Formats an integer immediate.
            </summary>
            <param name="value">The value to format.</param>
            <param name="type">The type of the literal.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>The string representation of the integer.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.FormatDefaultValueOfValueType(Phx.Types.AggregateType,System.IFormatProvider)">
            <summary>
            Format the default value of a value type.
            </summary>
            <param name="aggregateType">The value type to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>A string representation of the default value of the value type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.FormatDefaultValueOfTypeVariable(Phx.Types.TypeVariableType,System.IFormatProvider)">
            <summary>
            Format the default value of a type variable type.
            </summary>
            <param name="type">The type variable type to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>A string representation of the default value of the type variable type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.FormatIsInst(Phx.IR.Instruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats an isinst instruction as a use of the dynamic_cast operator.
            </summary>
            <param name="instruction">The isinst instruction to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>"dynamic_cast&lt;[type]&gt;([var])" where [var] is the variable be cast, and [type] is the destination type</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.FormatCall(Phx.IR.CallInstruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a method call.
            </summary>
            <param name="callInstruction">The call to format.</param>
            <param name="useType">The type that the destination of <paramref name="callInstruction"/> had when it it was used.</param>
            <param name="definitionType">The type that <paramref name="callInstruction"/> results in.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted method call.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.GetNewArrayString(System.IFormatProvider,System.String,System.Int32,System.String)" -->
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.ArrayPrefix">
            <summary>
            Gets the string to use for prefixing an array.  "[" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.ArraySuffix">
            <summary>
            Gets the string to use for suffixing an array.  "]" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.BitwiseOrOperator">
            <summary>
            Gets the string to use to represent a bitwise OR operation.  "|" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.ClassSeparator">
            <summary>
            Gets the string to use for seperating the namespace name from the class name, 
            or the class name from a static method name.  "::" in C++.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.PointerAccess">
            <summary>
            Gets the string to use for seperating the class name from an instance method name
            when accessed through a pointer.  "->" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.ReferenceAccess">
            <summary>
            Gets the string to use for seperating the class name from an instance method name
            when accessed through a reference.  "." in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.ManagedPointerDefinitionSymbol">
            <summary>
            Gets the string to use for declaring a managed pointer.  "^" in C++.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter.StringConcatOperator">
            <summary>
            Gets the string to use to represent a string concatenation operation.  "+" in C#.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeHelper">
            <summary>
            Helper methods for Dispose related analysis.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeHelper.IsDisposeOwnershipTransferLikely(Phx.Types.Type)">
            <summary>
            Returns true if the given type typically has its dispose ownership transfered when passed to a dispose creation call.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeHelper.GetInnerDisposableOperand(Phx.IR.CallInstruction)">
            <summary>
            Given a call instruction that takes a disposable operand, returns that disposable operand
            if the destination operand of this instruction takes ownership of disposing that disposable source operand.
            </summary>
            <remarks>
            Currently relies on the heuristic that almost all disposable creation calls that take a stream 
            end up taking ownership of disposing that stream.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeHelper.GetInnerDisposableOperandCore(Phx.IR.CallInstruction)">
            <summary>
            Given a call instruction that takes a disposable operand, returns that disposable operand
            if the destination operand of this instruction takes ownership of disposing that disposable source operand.
            </summary>
            <remarks>
            Currently relies on the heuristic that almost all disposable creation calls that take a stream 
            end up taking ownership of disposing that stream.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeHelper.IsTypeDisposable(Phx.Types.Type)">
            <summary>
            Returns true if the given type is derived from System.IDisposable, or is an object pointer
            to a disposable type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeHelper.IsDisposableTypeCreationCall(Phx.IR.CallInstruction)">
            <summary>
            Returns true if the instruction is creating a disposable type instance
            </summary>
            <remarks>
            This function returns false for disposable creation calls that take ownership of 
            another disposable object.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeHelper.IsDisposableTypeCreationCallCore(Phx.IR.CallInstruction)">
            <summary>
            Returns true if the instruction is creating a disposable type instance
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeHelper.GetDisposeMethodKind(Phx.IR.CallInstruction)">
            <summary>
            Returns true if the given <see cref="T:Phx.IR.CallInstruction"/> is a call to a dispose method.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeHelper.GetDisposeMethodKind(Phx.Symbols.FunctionSymbol)">
            <summary>
            Returns true if the given <see cref="T:Phx.Symbols.FunctionSymbol"/> is a dispose method.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeHelper.IDisposableTypeReference">
            <summary>
            Type reference for System.IDisposable
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeHelper.IDisposableDerivedTypeReference">
            <summary>
            Type reference for any type derived from System.IDisposable
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeHelper.DisposeMethodReference">
            <summary>
            Method reference for System.IDisposable.Dispose()
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeHelper.DisposeBoolMethodReference">
            <summary>
            Method reference for *.Dispose(bool)
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeHelper.CloseMethodReference">
            <summary>
            Method reference for a method named "Close" a type derived from System.IDisposable
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeMethodKind">
            <summary>
            Describes different kinds of Dispose-like methods.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeMethodKind.None">
            <summary>
            Not a dispose-like method.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeMethodKind.Dispose">
            <summary>
            An override of System.IDisposable.Dispose.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeMethodKind.DisposeBool">
            <summary>
            A virtual method named Dispose that takes a single Boolean parameter, as
            is used when implementing the standard Dispose pattern.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DisposeMethodKind.Close">
            <summary>
            A method named Close on a type that implements System.IDisposable.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.InstantiatedTypeReference">
            <summary>
            A reference to any instantiation of a specified generic CLR type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.InstantiatedTypeReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference[])">
            <summary>
            Constructor for InstantiatedTypeReference.
            </summary>
            <param name="genericType">The generic type.</param>
            <param name="genericArgumentTypes">The generic argument types.</param>
            <remarks>
            The InstantiatedTypeReference object will match any type that is an instantiation of <paramref name="genericType"/>
            with argument types that match the types specified in <paramref name="genericArgumentTypes"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.InstantiatedTypeReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.GenericArgumentListReference)">
            <summary>
            Constructor for InstantiatedTypeReference.
            </summary>
            <param name="genericType">The generic type.</param>
            <param name="genericArgumentTypes">The generic argument types.</param>
            <remarks>
            The InstantiatedTypeReference object will match any type that is an instantiation of <paramref name="genericType"/>
            with argument types that match the types specified in <paramref name="genericArgumentTypes"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.InstantiatedTypeReference.MatchesType(Phx.Types.Type)">
            <summary>
            Determine if the specified Phoenix type refers to or derives from this type reference.
            </summary>
            <param name="type">Phoenix type to compare evaluate.</param>
            <returns>'true' if the specified type refers to or derives from this type reference.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.InstantiatedTypeReference.ToString">
            <summary>
            String representation of the TypeReference.
            </summary>
            <remarks>This is used for debugging only.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.LanguageManager.GetSourceLanguage(Phx.PEModuleUnit)">
            <summary>
            Get the <see cref="T:Microsoft.VisualStudio.CodeAnalysis.SourceLanguage"/> that <paramref name="moduleUnit"/> is written in.
            </summary>
            <param name="moduleUnit">The <see cref="T:Microsoft.VisualStudio.CodeAnalysis.SourceLanguage"/> whose <see cref="T:Phx.PEModuleUnit"/> is needed.</param>
            <returns>The <see cref="T:Microsoft.VisualStudio.CodeAnalysis.SourceLanguage"/> that <paramref name="moduleUnit"/> is written in.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.OverrideMethodReference">
            <summary>
            Represents a reference to any CLR method that overrides a specified method.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodReference">
            <summary>
            Represents a reference to a method of a CLR type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodReference.MatchesFunctionSymbol(Phx.Symbols.FunctionSymbol)">
            <summary>
            Determine if this method reference refers to the specified Phoenix method.
            </summary>
            <param name="functionSymbol">Phoenix FunctionSymbol to compare to this method reference.</param>
            <returns>'true' if this method reference refers to the specified FunctionSymbol.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.OverrideMethodReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodReference,System.Boolean)">
            <summary>
            Constructor for OverrideMethodReference.
            </summary>
            <param name="introducingMethod">A MethodReference to the introducing method whose overrides are to be matched.</param>
            <param name="matchSelf">'true' if the new OverrideMethodReference should match the introducing method itself, 'false' if it should match only strict overrides
            of the introducing method.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.OverrideMethodReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodReference)">
            <summary>
            Constructor for OverrideMethodReference.
            </summary>
            <param name="introducingMethod">A MethodReference to the introducing method whose overrides are to be matched.</param>
            <remarks>
            The new OverrideMethodReference will match any method that overrides the specified introducing method, including the introducing method itself.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.OverrideMethodReference.MatchesFunctionSymbol(Phx.Symbols.FunctionSymbol)">
            <summary>
            Determine if this method reference refers to the specified Phoenix method.
            </summary>
            <param name="functionSymbol">Phoenix FunctionSymbol to compare to this method reference.</param>
            <returns>'true' if this method reference refers to the specified FunctionSymbol.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.Tuple`2">
            <summary>
            Tuple struct as proposed in ECMA TR-089
            </summary>
            <typeparam name="A"></typeparam>
            <typeparam name="B"></typeparam>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.Tuple`3">
            <summary>
            Tuple struct as proposed in ECMA TR-089
            </summary>
            <typeparam name="A"></typeparam>
            <typeparam name="B"></typeparam>
            <typeparam name="C"></typeparam>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter">
            <summary>
            An expression formatter for rendering Phoenix expressions as C# source code.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.GetDisplayName(Microsoft.VisualStudio.CodeAnalysis.AnalysisResults.Keyword)">
            <summary>
            Gets the display name for the specified <see cref="T:Microsoft.VisualStudio.CodeAnalysis.AnalysisResults.Keyword"/>
            </summary>
            <param name="keyword">The keyword to get the display name for.</param>
            <returns>The display name of <paramref name="keyword"/></returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.GetDisplayName(Phx.ExtensibleObject)">
            <summary>
            Gets the display name for the specified <see cref="T:Phx.ExtensibleObject"/>
            </summary>
            <param name="node">The Phoenix object to get the display name for.</param>
            <returns><paramref name="node"/>'s display name.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.FormatArgument(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfo,System.IFormatProvider)">
            <summary>
            Formats a single argument of a <see cref="T:Phx.IR.CallInstruction"/>.
            </summary>
            <param name="argumentInfo">
            The <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ArgumentInfo"/> containing the <see cref="T:Phx.IR.Operand"/> and <see cref="T:Phx.Types.Parameter"/> information to format.
            </param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted argument.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedParamArrayAnalysis,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedCopyAnalysis,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedStringValueAnalysis)">
            <summary>
            Primary constructor for a CSharpExpressionFormatter.
            </summary>
            <param name="paramArrayAnalysis">SharedParamArrayAnalysis to use for extracting individual arguments from a parameters array.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.FindCallSiteBinderCreationInstruction(Phx.IR.CallInstruction)">
            <summary>
            If the specified call instruction, is a dynamic operation, finds the call instruction that created the call site binder for
            the operation.
            </summary>
            <param name="callInstruction">The call instruction of the possibly dynamic operation.</param>
            <returns>The call instruction that created the call site binder for the operation, or null if the call does not
            appear to be a dynamic operation.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.FormatCall(Phx.IR.CallInstruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a method call.
            </summary>
            <param name="callInstruction">The call to format.</param>
            <param name="useType">The type that the destination of <paramref name="callInstruction"/> had when it it was used.</param>
            <param name="definitionType">The type that <paramref name="callInstruction"/> results in.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted method call.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.ConvertArgumentInfoFlags(System.Int64)">
            <summary>
            Converts the integer value of a CSharpArgumentInfoFlags enum to an ArgumentInfoOptions enum.
            </summary>
            <param name="value">The value of the CSharpArgumentInfoFlags enum.</param>
            <returns>The converted ArgumentInfoOptions enum.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.ResolveEnumConstantValue(Phx.IR.Operand)">
            <summary>
            Resolves the constant value of an enum operand.
            </summary>
            <param name="operand">The operand whose value is to be resolved.</param>
            <returns>The value of the operand, or null if the value cannot be resolved.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.ResolveExpressionType(Phx.IR.Operand)">
            <summary>
            Resolves the value of an ExpressionType enum operand.
            </summary>
            <param name="operand">The operand whose value is to be resolved.</param>
            <returns>The value of the operand, or null if the value cannot be resolved.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.GetArgumentInfo(Phx.IR.Operand,Phx.Types.ParameterKind,System.Collections.Generic.IList{Phx.IR.Operand},System.Int32)">
            <summary>
            Get an ArgumentInfo object describing the argument to a dynamic operation.
            </summary>
            <param name="argumentOperand">The argument operand.</param>
            <param name="parameterKind">The kind of parameter to which the argument is passed.</param>
            <param name="argumentInfoOperands">List of operands containing CSharpArgumentInfo objects describing the arguments to the operation.</param>
            <param name="argumentIndex">The index of the argument.</param>
            <returns>An ArgumentInfo object describing the argument.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.FormatDynamicConvert(Phx.IR.CallInstruction,System.IFormatProvider)">
            <summary>
            Format a dynamic convert operation.
            </summary>
            <param name="callInstruction">The call to Invoke on the delegate.</param>
            <param name="formatProvider">Format provider to use when formatting the expression.</param>
            <returns>The formatted expression, or null if the expression could not be formatted.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.FormatDynamicBinaryOperation(Phx.IR.CallInstruction,Phx.IR.CallInstruction,System.IFormatProvider)">
            <summary>
            Format a dynamic binary operation.
            </summary>
            <param name="callInstruction">The call to Invoke on the delegate.</param>
            <param name="binderCreationInstruction">The call that created the call site binder.</param>
            <param name="formatProvider">Format provider to use when formatting the expression.</param>
            <returns>The formatted expression, or null if the expression could not be formatted.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.FormatDynamicUnaryOperation(Phx.IR.CallInstruction,Phx.IR.CallInstruction,System.IFormatProvider)">
            <summary>
            Format a dynamic unary operation.
            </summary>
            <param name="callInstruction">The call to Invoke on the delegate.</param>
            <param name="binderCreationInstruction">The call that created the call site binder.</param>
            <param name="formatProvider">Format provider to use when formatting the expression.</param>
            <returns>The formatted expression, or null if the expression could not be formatted.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.FormatDynamicGetMember(Phx.IR.CallInstruction,Phx.IR.CallInstruction,System.IFormatProvider)">
            <summary>
            Format a dynamic member access operation.
            </summary>
            <param name="callInstruction">The call to Invoke on the delegate.</param>
            <param name="binderCreationInstruction">The call that created the call site binder.</param>
            <param name="formatProvider">Format provider to use when formatting the expression.</param>
            <returns>The formatted expression, or null if the expression could not be formatted.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.FormatDynamicInvoke(Phx.IR.CallInstruction,Phx.IR.CallInstruction,System.IFormatProvider)">
            <summary>
            Format a dynamic invoke operation.
            </summary>
            <param name="callInstruction">The call to Invoke on the delegate.</param>
            <param name="binderCreationInstruction">The call that created the call site binder.</param>
            <param name="formatProvider">Format provider to use when formatting the expression.</param>
            <returns>The formatted expression, or null if the expression could not be formatted.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.FormatDynamicInvokeMember(Phx.IR.CallInstruction,Phx.IR.CallInstruction,System.IFormatProvider)">
            <summary>
            Format a dynamic member invoke operation.
            </summary>
            <param name="callInstruction">The call to Invoke on the delegate.</param>
            <param name="binderCreationInstruction">The call that created the call site binder.</param>
            <param name="formatProvider">Format provider to use when formatting the expression.</param>
            <returns>The formatted expression, or null if the expression could not be formatted.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.FormatDynamicGetIndex(Phx.IR.CallInstruction,Phx.IR.CallInstruction,System.IFormatProvider)">
            <summary>
            Format a dynamic indexer operation.
            </summary>
            <param name="callInstruction">The call to Invoke on the delegate.</param>
            <param name="binderCreationInstruction">The call that created the call site binder.</param>
            <param name="formatProvider">Format provider to use when formatting the expression.</param>
            <returns>The formatted expression, or null if the expression could not be formatted.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.GetArguments(Phx.IR.CallInstruction,System.Collections.Generic.IList{Phx.IR.Operand})">
            <summary>
            Get a list of ArgumentInfo objects describing the arguments to a dynamic operation.
            </summary>
            <param name="callInstruction">The call to Invoke on the delegate.</param>
            <param name="argumentInfoOperands">List of operands containing CSharpArgumentInfo objects describing the arguments to the operation.</param>
            <returns>A list describing the arguments to the operation, or null if the arguments could not be computed.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.FormatIsInst(Phx.IR.Instruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats an isinst instruction as a use of the 'as' operator.
            </summary>
            <param name="instruction">The isinst instruction to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>"[var] as [type]" where [var] is the variable be cast, and [type] is the destination type</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.FormatDefaultValueOfValueType(Phx.Types.AggregateType,System.IFormatProvider)">
            <summary>
            Format the default value of a value type.
            </summary>
            <param name="aggregateType">The value type to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>A string representation of the default value of the value type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.FormatDefaultValueOfTypeVariable(Phx.Types.TypeVariableType,System.IFormatProvider)">
            <summary>
            Format the default value of a type variable type.
            </summary>
            <param name="type">The type variable type to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>A string representation of the default value of the type variable type.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.ArrayPrefix">
            <summary>
            Gets the string to use for prefixing an array.  "[" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.ArraySuffix">
            <summary>
            Gets the string to use for suffixing an array.  "]" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.BitwiseOrOperator">
            <summary>
            Gets the string to use to represent a bitwise OR operation.  "|" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.ClassSeparator">
            <summary>
            Gets the string to use for seperating the namespace name from the class name, 
            or the class name from a static method name.  "::" in C++.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.PointerAccess">
            <summary>
            Gets the string to use for seperating the class name from an instance method name
            when accessed through a pointer.  "->" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.ReferenceAccess">
            <summary>
            Gets the string to use for seperating the class name from an instance method name
            when accessed through a reference.  "." in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.ManagedPointerDefinitionSymbol">
            <summary>
            Gets the string to use for declaring a managed pointer.  "^" in C++.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter.StringConcatOperator">
            <summary>
            Gets the string to use to represent a string concatenation operation.  "+" in C#.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DecoratedNamedMethodReference">
            <summary>
            Represents a reference to a C++ method with a specified decorated name.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DecoratedNamedMethodReference.#ctor(System.String)">
            <summary>
            Constructor for DecoratedNamedMethodReference.
            </summary>
            <param name="decoratedName">The decorated name of the method to be matched.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DecoratedNamedMethodReference.MatchesFunctionSymbol(Phx.Symbols.FunctionSymbol)">
            <summary>
            Determine if this method reference refers to the specified Phoenix method.
            </summary>
            <param name="functionSymbol">Phoenix FunctionSymbol to compare to this method reference.</param>
            <returns>'true' if this method reference refers to the specified FunctionSymbol.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DecoratedNamedMethodReference.ToString">
            <summary>
            String representation of the DecoratedNamedMethodReference.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DerivedTypeReference">
            <summary>
            A reference to a CLR type or any type derived from it.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DerivedTypeReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,System.Boolean)">
            <summary>
            Constructor for DerivedTypeReference.
            </summary>
            <param name="baseType">The base type.</param>
            <param name="matchSelf">Specifies whether this DerivedTypeReference should match the type specified
            by <paramref name="baseType"/>, or only types that are strictly derived from <paramref name="baseType"/>.</param>
            <remarks>
            The DerivedTypeReference object will match any type that is derived, directly or indirectly, from the <paramref name="baseType"/>. If
            <paramref name="matchSelf"/> is true, the reference will also match <paramref name="baseType"/> itself.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DerivedTypeReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>
            Constructor for DerivedTypeReference.
            </summary>
            <param name="baseType">The base type.</param>
            <remarks>
            The DerivedTypeReference object will match any type that is derived, directly or indirectly, from the <paramref name="baseType"/>,
            as well as <paramref name="baseType"/> itself.
            </remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DerivedTypeReference.MatchesType(Phx.Types.Type)">
            <summary>
            Determine if the specified Phoenix type refers to or derives from this type reference.
            </summary>
            <param name="type">Phoenix type to compare evaluate.</param>
            <returns>'true' if the specified type refers to or derives from this type reference.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.DerivedTypeReference.ToString">
            <summary>
            String representation of the TypeReference.
            </summary>
            <remarks>This is used for debugging only.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ResolutionFormatter">
            <summary>
            Class that converts Phoenix symbols to a resolution string formatted in the style of a given programming language.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ResolutionFormatter.GetResolutionName(Phx.ExtensibleObject,Microsoft.VisualStudio.CodeAnalysis.SourceLanguage)">
            <summary>
            Converts a Phoenix symbol (like a function or type) into a user readable resolution string formatted in the style of 
            the given <see cref="T:Microsoft.VisualStudio.CodeAnalysis.SourceLanguage"/>.
            </summary>
            <param name="node">The Phoenix Symbol to convert to a string. 
            Note that this is not typed to a Phoenix symbol because certain types that act as symbols
            do not actually derive from Symbol (like ParameterSymbol).</param>
            <param name="language">Specifies the programming language style the string should be formatted in.</param>
            <returns>User readable string formatted in the style of the given <see cref="T:Microsoft.VisualStudio.CodeAnalysis.SourceLanguage"/>.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ResolutionFormatter.TryGetResolutionName(Phx.ExtensibleObject)">
            <summary>
            Returns a CSharp resolution display string or "Unknown" if errors occured while formatting the given Phoenix object.
            </summary>
            <remarks>Will not throw exceptions.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatterComponent">
            <summary>
            A component for accessing expression formatters by source language.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatterComponent.GetExpressionFormatter(Microsoft.VisualStudio.CodeAnalysis.SourceLanguage)">
            <summary>
            Gets an expression formatter for a particular source language.
            </summary>
            <param name="sourceLanguage">The source language to format expressions in.</param>
            <returns>An expression formatter for the given language.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatterComponent.GetExpressionFormatter(Phx.PEModuleUnit)">
            <summary>
            Gets an expression formatter for the particular language that <paramref name="moduleUnit"/> is written in."
            </summary>
            <param name="moduleUnit">The <see cref="T:Phx.PEModuleUnit"/> that contains the expressions that are going to be formatted.</param>
            <returns>An expression formatter for the language used in <paramref name="moduleUnit"/>.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatterService">
            <summary>
            A service for accessing expression formatters by source language.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatterService.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CSharpExpressionFormatter,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.CPlusPlusExpressionFormatter,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter)">
            <summary>
            Constructor for the ExpressionFormatterService.  Takes a formatter for each language we can format.
            </summary>
            <param name="cSharpExpressionFormatter">The formatter to use for C#.</param>
            <param name="cPlusPlusExpressionFormatter">The formatter to use for C++.</param>
            <param name="visualBasicExpressionFormatter">The formatter to use for Visual Basic.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatterService.GetExpressionFormatter(Microsoft.VisualStudio.CodeAnalysis.SourceLanguage)">
            <summary>
            Gets an expression formatter for a particular source language.
            </summary>
            <param name="sourceLanguage">The source language to format expressions in.</param>
            <returns>An expression formatter for the given language.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionFormatterService.GetExpressionFormatter(Phx.PEModuleUnit)">
            <summary>
            Gets an expression formatter for the particular language that <paramref name="moduleUnit"/> is written in."
            </summary>
            <param name="expression">The <see cref="T:Phx.PEModuleUnit"/> that contains the expressions that are going to be formatted.</param>
            <returns>An expression formatter for the language used in <paramref name="moduleUnit"/>.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionUtilities">
            <summary>
            The purpose of this class is to provide utilities for dealing with expressions.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionUtilities.GetUnderlyingType(Phx.Types.Type)">
            <summary>Unwraps the type if it is a pointer and gives you the actual type it was refering to.</summary>
            <param name="type">The type to unwrap if nessessary.</param>
            <returns>The underlying type that was being refered to.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionUtilities.IsParamsArrayArgument(Phx.IR.ArgumentWithParameter)">
            <summary>Determines if the FunctionArgument is a params array parameter.</summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionUtilities.IsHazardousIfNull(Phx.IR.Operand)">
            <summary>
            Determine if an operand would cause an exception if it had a value of null.
            </summary>
            <param name="operand">The operand to be queried.</param>
            <returns>'true' if executing the instruction containing the operand would result in an exception
            if the value of the operand were null.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ExpressionUtilities.IsOverrunableBuffer(Phx.IR.Operand)">
            <summary>
            Determines whether an operand is a buffer that could potentially be overrun.
            </summary>
            <param name="operand">the operand to check</param>
            <returns>true if the operand is a pointer and is not an object pointer</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FieldReference">
            <summary>
            Represents a reference to a field of a CLR type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FieldReference.MatchesFieldSymbol(Phx.Symbols.FieldSymbol)">
            <summary>
            Determine if this field reference refers to the specified Phoenix field.
            </summary>
            <param name="fieldSymbol">Phoenix FieldSymbol to compare to this field reference.</param>
            <returns>'true' if this field reference refers to the specified FieldSymbol.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FieldReference.MatchesFieldSymbol(Phx.Symbols.StaticFieldSymbol)">
            <summary>
            Determine if this field reference refers to the specified Phoenix static field.
            </summary>
            <param name="staticFieldSymbol">Phoenix StaticFieldSymbol to compare to this field reference.</param>
            <returns>'true' if this field reference refers to the specified StaticFieldSymbol.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FieldSymbolExtensions">
            <summary>
            Extension methods for use with Phoenix field symbols.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FieldSymbolExtensions.IsCompilerGenerated(Phx.Symbols.FieldSymbol)">
            <summary>
            Return true if the specified field symbol is marked as compiler generated.
            </summary>
            <param name="fieldSymbol">The field symbol to test.</param>
            <returns>'true' if <paramref name="fieldSymbol"/> is compiler generated.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FormatItem">
            <summary>
            Represents a single format item within a format string.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FormatItem.ToString">
            <summary>
            Convert the FormatItem to a human-readable string.
            </summary>
            <returns>A string representation of the FormatItem.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FormatItem.Index">
            <summary>
            The index of the format argument referenced by this format item (e.g. '3' for {3:hh}).
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FormatItem.Alignment">
            <summary>
            The kind of alignment specified by this format item (e.g. 'Left' for {3,-2}).
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FormatItem.MinimumWidth">
            <summary>
            The minimum width specified by this format item (e.g. '2' for {3,-2}).
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FormatItem.FormatString">
            <summary>
            The custom format string specified by this format item (e.g. 'hh' for {3:hh}).
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FormatItemAlignment">
            <summary>
            Alignment kind used by FormatItem.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FormatItemAlignment.None">
            <summary>
            The format item is not aligned.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FormatItemAlignment.Left">
            <summary>
            The format item is left-aligned.
            </summary>
        </member>
        <member name="F:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FormatItemAlignment.Right">
            <summary>
            The format item is right-aligned.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FrameworkTypeUtilities">
            <summary>
            The purpose of this class is to provide utilities for identifying and dealing with framework types.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FrameworkTypeUtilities.IsStringParameter(Phx.Types.Parameter)">
            <summary>Evaluates if the given Parameter is a System.String type.</summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FrameworkTypeUtilities.IsStringOperand(Phx.IR.Operand)">
            <summary>
            Determines if the specified operand is a System.String.
            </summary>
            <param name="operand">The operand to test.</param>
            <returns>'true' if the specified operand is of the type System.String.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FrameworkTypeUtilities.IsObjectOperand(Phx.IR.Operand)">
            <summary>
            Determines if the specified operand is a System.Object.
            </summary>
            <param name="operand">The operand to test.</param>
            <returns>'true' if the specified operand is of the type System.Object.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FullyQualifiedName">
            <summary>
            This is a temporary solution for generating the full name for symbols until the NameProvider stuff can be ported.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FullyQualifiedName.Format(Phx.IR.Operand)">
            <summary>
            This is a temporary solution for generating the full name for symbols until the NameProvider stuff can be ported.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FullyQualifiedName.Format(Phx.Symbols.Symbol)">
            <summary>
            This is a temporary solution for generating the full name for symbols until the NameProvider stuff can be ported.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FunctionSymbolExtensions">
            <summary>
            Helper methods for the Phx.Symbols.FunctionSymbol type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FunctionSymbolExtensions.GetOverrideHistory(Phx.Symbols.FunctionSymbol)">
            <summary>
            Gets a collection of all of the base class implementations and definitions of this method.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FunctionSymbolExtensions.GetPrimaryIntroducingFunction(Phx.Symbols.FunctionSymbol)">
            <summary>
            Gets the primary introducing virtual function of this FunctionSymbol.
            </summary>
            <param name="functionSymbol">The FunctionSymbol whose primary introducing function is to be retrieved.</param>
            <returns>An <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Types.IntroducingFunctionReference"/> object that identifies the primary introducing function.</returns>
            <remarks>A virtual function may override multiple introducing functions. The primary introducing function is the function
            whose virtual function table slot will be used if a virtual call to this function is executed.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FunctionSymbolExtensions.IsIntroducing(Phx.Symbols.FunctionSymbol)">
            <summary>
            Is this function an introducing virtual function?
            </summary>
            <param name="functionSymbol">The function symbol to test.</param>
            <returns>'true' if the function is an introducing virtual function, 'false' otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FunctionSymbolExtensions.GetFunctionSymbolOnInstantiatedType(Phx.Symbols.FunctionSymbol,Phx.Types.AggregateType)">
            <summary>
            Gets the function symbol on an instantiated type that corresponds to this function symbol.
            </summary>
            <param name="functionSymbol">The function symbol whose corresponding function is to be retrieved.</param>
            <param name="instantiatedType">The instantiated generic type on which to find the corresponding function.</param>
            <returns>The function on <paramref name="instantiatedType"/> that corresponds to the specified function.</returns>
            <remarks>The <paramref name="functionSymbol"/> parameter may be a function on an uninstantiated generic type, or on a type that
            is an instantiation of the same generic type from which <paramref name="instantiatedType"/> was instantiated.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FunctionSymbolExtensions.GetDeclaringProperty(Phx.Symbols.FunctionSymbol)">
            <summary>Takes a get or set FunctionSymbol and returns its coresponding PropertySymbol.</summary>
            <remarks>It is theoretically possible for more than one property to point to the same get or set method. 
            This method just returns the first matching PropertySymbol it finds.</remarks>
            <param name="functionSymbol">A get or set FunctionSymbol.</param>
            <returns>Returns null if no coresponding PropertySymbol is found.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FunctionSymbolExtensions.IsPropertyGetter(Phx.Symbols.FunctionSymbol)">
            <summary>
            Determines if the FunctionSymbol is the getter method of a property.
            </summary>
            <param name="functionSymbol">The FunctionSymbol to test.</param>
            <returns>'true' if <paramref name="functionSymbol"/> is the getter associated with
            a property.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FunctionSymbolExtensions.IsPropertySetter(Phx.Symbols.FunctionSymbol)">
            <summary>
            Determines if the FunctionSymbol is the setter method of a property.
            </summary>
            <param name="functionSymbol">The FunctionSymbol to test.</param>
            <returns>'true' if <paramref name="functionSymbol"/> is the setter associated with
            a property.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FunctionSymbolExtensions.GetDeclaringEvent(Phx.Symbols.FunctionSymbol)">
            <summary>Takes a get or set FunctionSymbol and returns its coresponding EventSymbol.</summary>
            <remarks>It is theoretically possible for more than one Event to point to the same accessor method. 
            This method just returns the first matching EventSymbol it finds.</remarks>
            <param name="functionSymbol">An event accessor (add/remove/fire) FunctionSymbol.</param>
            <returns>Returns null if no coresponding EventSymbol is found.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FunctionSymbolExtensions.IsCallableFromOutsideAssembly(Phx.Symbols.FunctionSymbol)">
            <summary>
            Determines if the specific function can be called from outside of the assembly that declares it.
            </summary>
            <param name="functionSymbol">The function to be tested.</param>
            <returns>'true' if the function can be called from outside the assembly that declares it.</returns>
            <remarks>Any function that is visible outside of its assembly can be called from outside the assembly. In addition,
            a function can be called from outside its assembly if it overrides a function that is either visible outside the assembly,
            or is declared in a different assembly.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FunctionSymbolExtensions.IsAnonymousMethod(Phx.Symbols.FunctionSymbol)">
            <summary>
                Returns a value indicating whether the specified <see cref="T:Phx.Symbols.FunctionSymbol"/> is an anonymous method.
            </summary>
            <param name="functionSymbol">
                The <see cref="T:Phx.Symbols.FunctionSymbol"/> of the method to check.
            </param>
            <returns>
                <see langword="true"/> if <paramref name="functionSymbol"/> is an anonymous method, otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FunctionSymbolExtensions.GetDeclaringMethod(Phx.Symbols.FunctionSymbol)">
            <summary>
                Returns the <see cref="T:Phx.Symbols.FunctionSymbol"/> of the specified anonymous method's declaring method.
            </summary>
            <param name="anonymousMethod">
                The anonymous method whose declaring method is needed.
            </param>
            <returns>
                The <see cref="T:Phx.Symbols.FunctionSymbol"/> for the method that declares<paramref name="anonymousMethod"/> or 
                <see langword="null"/> if <paramref name="anonymousMethod"/> is not an anonymous method.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FunctionSymbolExtensions.GetAnonymousMethods(Phx.Symbols.FunctionSymbol)">
            <summary>
                Returns the anonymous method <see cref="T:Phx.Symbols.FunctionSymbol"/>s that are declared in <paramref name="declaringMethod"/>.
            </summary>
            <param name="declaringMethod">
                The <see cref="T:Phx.Symbols.FunctionSymbol"/> of method whose anonymous methods will be returned.
            </param>
            <returns>
                A <see cref="T:System.Collections.Generic.ICollection`1"/> containing the anonymous method <see cref="T:Phx.Symbols.FunctionSymbol"/>s 
                of <paramref name="declaringMethod"/> or <see langword="null"/> if 
                <paramref name="declaringMethod"/> does not have any anonymous methods.
            </returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.FunctionSymbolExtensions.IsCompilerGenerated(Phx.Symbols.FunctionSymbol)">
            <summary>
            Return true if the specified function symbol is marked as compiler generated.
            </summary>
            <param name="functionSymbol">The function symbol to test.</param>
            <returns>'true' if <paramref name="functionSymbol"/> is compiler generated.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.GenericArgumentListReference">
            <summary>
            Represents a reference to the generic argument list a CLR method or type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.GenericArgumentListReference.MatchesArgumentList(Phx.Collections.Generic.List{Phx.Types.Type})">
            <summary>
            Determine if this generic argument list reference refers to the specified Phoenix generic argument list.
            </summary>
            <param name="typeList">Phoenix TypeList to compare to this generic argument list reference.</param>
            <returns>'true' if this generic argument list reference refers to the specified argument list.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.GenericArgumentListReference.None">
            <summary>
            A GenericArgumentListReference that matches an empty generic argument list.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.LiteralStringExpression">
            <summary>
            Class that provides a way for an IExpressionFormatter to format arbitrary string literals.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.LiteralStringExpression.#ctor(System.String)">
            <summary>
            Create a new <see cref="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.LiteralStringExpression"/>.
            </summary>
            <param name="expression">The literal <see cref="T:System.String"/> to format.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.LiteralStringExpression.LiteralString">
            <summary>
            Provides readonly access to the contained literal <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodReferenceDictionary`1">
            <summary>
            Dictionary that maps from FunctionSymbol to a user-specified value.  The dictionary is populated using
            MethodReference objects as the keys, but lookup is done using FunctionSymbols as the keys.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodReferenceDictionary`1.#ctor">
            <summary>
            Create a new MethodReferenceDictionary.
            </summary>
            <remarks>The default value for any method not in the dictionary is assumed to be default(TValue).</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodReferenceDictionary`1.#ctor(`0)">
            <summary>
            Create a new MethodReferenceDictionary.
            </summary>
            <param name="defaultValue">The default value to be returned when looking up a method that is not in the dictionary.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodReferenceDictionary`1.Add(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodReference,`0)">
            <summary>
            Add a mapping from a MethodReference to a user-specified value.
            </summary>
            <param name="methodReference">Reference to the method to use as a key.</param>
            <param name="value">User-specified value to map the method to.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodReferenceDictionary`1.Item(Phx.Symbols.FunctionSymbol)">
            <summary>
            Gets the value associated with a specified method.
            </summary>
            <param name="functionSymbol">FunctionSymbol of the method for which the value is to be retrieved.</param>
            <returns>The value associated with the specified method.  If the method is not found, the return value is the
            default value specified in the constructor.</returns>
            <remarks>If more than one key matches this function symbol, one of the matching values will be returned,
            but it is undefined which one is actually returned.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ModuleUnitExtensions">
            <summary>
            Extension methods for use with Phoenix module units.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ModuleUnitExtensions.GetSourceLanguage(Phx.ModuleUnit)">
            <summary>
            Gets the language that the module unit is written in.
            </summary>
            <param name="moduleUnit">The module unit whose language is desired.</param>
            <returns>The SourceLanguage that the module unit is written in.</returns>
            <remarks>If pdbs are missing, the source language will be computed using the contents of the module.
            In some cases the result of the computation may be incorrect.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedFieldReference">
            <summary>
            Represents a reference to a CLR field with a specified name.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedFieldReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,System.String,System.Boolean)">
            <summary>
            Creates a new NamedFieldReference object.
            </summary>
            <param name="enclosingType">The enclosing type of the field.</param>
            <param name="name">The name of the field.</param>
            <param name="isStatic">'true' if the field is a staitic field, 'false' if it is an instance field</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedFieldReference.MatchesFieldSymbol(Phx.Symbols.FieldSymbol)">
            <summary>
            Determines if this FieldReference refers to the specified Phoenix field symbol.
            </summary>
            <param name="fieldSymbol">The Phoenix FieldSymbol to compare to this field reference</param>
            <returns>'true' if this field refers to the specified field symbol.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedFieldReference.MatchesFieldSymbol(Phx.Symbols.StaticFieldSymbol)">
            <summary>
            Determines if this FieldReference refers to the specified Phoenix static field symbol.
            </summary>
            <param name="staticFieldSymbol">The Phoenix StaticFieldSymbol to compare to this field reference</param>
            <returns>'true' if this field refers to the specified static field symbol.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedFieldReference.ToString">
            <summary>
            String representation of the field reference.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedMethodReference">
            <summary>
            Represents a reference to a CLR method with a specified name.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedMethodReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,System.String,System.Boolean,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference[])">
            <summary>
            Create a new NamedMethodReference object.
            </summary>
            <param name="enclosingType">The type that contains the method.</param>
            <param name="name">The name of the method, as it appears in metadata.</param>
            <param name="isInstanceMethod">'true' if the method is an instance method, 'false' if it is a static method.</param>
            <param name="returnType">The return type of the method.  This may be null to indicate that the method returns void.</param>
            <param name="parameterTypes">The types of the parameters of the method (not including the 'this' parameter).</param>
            <remarks>The calling convention is assumed to be ClrCall.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedMethodReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,System.String,Phx.Types.CallingConventionKind,System.Boolean,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference[])">
            <summary>
            Create a new NamedMethodReference object.
            </summary>
            <param name="enclosingType">The type that contains the method.</param>
            <param name="name">The name of the method, as it appears in metadata.</param>
            <param name="callingConvention">The calling convention of the method.</param>
            <param name="isInstanceMethod">'true' if the method is an instance method, 'false' if it is a static method.</param>
            <param name="returnType">The return type of the method.  This may be null to indicate that the method returns void.</param>
            <param name="parameterTypes">The types of the parameters of the method (not including the 'this' parameter).</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedMethodReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,System.String)">
            <summary>
            Create a new NamedMethodReference object.
            </summary>
            <param name="enclosingType">The type that contains the method.</param>
            <param name="name">The name of the method, as it appears in metadata.</param>
            <remarks>The NamedMethodReference will match any method on the specified type with the specified name, regardless of signature.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedMethodReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,System.String,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodSignatureReference)">
            <summary>
            Create a new NamedMethodReference object.
            </summary>
            <param name="enclosingType">The type that contains the method.</param>
            <param name="name">The name of the method, as it appears in metadata.</param>
            <param name="signature">The signature of the method.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedMethodReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,System.String,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.MethodSignatureReference,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.GenericArgumentListReference)">
            <summary>
            Create a new NamedMethodReference object.
            </summary>
            <param name="enclosingType">The type that contains the method.</param>
            <param name="name">The name of the method, as it appears in metadata.</param>
            <param name="signature">The signature of the method.</param>
            <param name="genericArguments">The types of the generic arguments of the method.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedMethodReference.MatchesFunctionSymbol(Phx.Symbols.FunctionSymbol)">
            <summary>
            Determine if this method reference refers to the specified Phoenix method.
            </summary>
            <param name="functionSymbol">Phoenix FunctionSymbol to compare to this method reference.</param>
            <returns>'true' if this method reference refers to the specified FunctionSymbol.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedMethodReference.ToString">
            <summary>
            String representation of the MethodReference.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedTypeReference">
            <summary>
            A reference to a CLR type with a specific name.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedTypeReference.#ctor(System.String)">
            <summary>
            Create a new NamedTypeReference object for a non-nested type.
            </summary>
            <param name="name">The name of the type, as it appears in metadata (e.g. "System.Object", or "System.Collections.Generic.List`1").</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedTypeReference.#ctor(System.String,System.Int32)">
            <summary>
            Create a new NamedTypeReference object for a non-nested type.
            </summary>
            <param name="name">The name of the type, as it appears in metadata (e.g. "System.Object", or "System.Collections.Generic.List`1").</param>
            <param name="genericArity">The number of generic parameters this type takes.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedTypeReference.#ctor(System.String,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>
            Create a new NamedTypeReference object.
            </summary>
            <param name="name">The name of the type, as it appears in metadata (e.g. "System.Object", or "System.Collections.Generic.List`1").</param>
            <param name="enclosingType">A type reference to the type that contains the type to be referred to, or null if the type is not nested.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedTypeReference.#ctor(System.String,System.Int32,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>
            Create a new NamedTypeReference object.
            </summary>
            <param name="name">The name of the type, as it appears in metadata (e.g. "System.Object", or "System.Collections.Generic.List`1").</param>
            <param name="genericArity">The number of generic parameters this type takes.</param>
            <param name="enclosingType">A type reference to the type that contains the type to be referred to, or null if the type is not nested.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedTypeReference.MatchesType(Phx.Types.Type)">
            <summary>
            Determine if this type reference refers to the specified Phoenix type
            </summary>
            <param name="type">Phoenix type to compare to this type reference.</param>
            <returns>'true' if this type reference refers to the specified type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.NamedTypeReference.ToString">
            <summary>
            String representation of the TypeReference.
            </summary>
            <remarks>This is used for debugging only.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.OperandExtensions">
            <summary>
            Extension methods for use with Phoenix operands.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.OperandExtensions.GetDefinedParameter(Phx.IR.Operand)">
            <summary>
            Gets the <see cref="T:Phx.Symbols.ParameterSymbol"/> of parameter that this operand defines, if any.
            </summary>
            <param name="operand">The operand to test.</param>
            <returns>If the operand is the definition of a parameter, returns the <see cref="T:Phx.Symbols.ParameterSymbol"/>.
            of the parameter being defined.  Otherwise, returns null.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.OperandExtensions.IsNullPtr(Phx.IR.Operand)">
            <summary>
            Returns true if this Operand is a null pointer operand.
            </summary>
            <param name="operand">The operand to test.</param>
            <returns>Returns true if this Operand is a null pointer operand, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.OperandExtensions.GetOriginalRenamedOptimizedOperandDefinition(Phx.IR.Operand)">
            <summary>
            Returns the original operand definition if this operand was renamed during rename optimimzation.
            </summary>
            <param name="operand">The operand which replaced another operand in rename optimization.</param>
            <returns>The definitionOperand of the original operand or null</returns>
            <remarks>
            If <paramref name="operand"/> replaced any operand during rename optimization 
            it returns the definition Operand of the original operand Otherwise returns null.
            </remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParameterSymbolExtensions">
            <summary>
            Extension methods for use with Phoenix parameter symbols.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParameterSymbolExtensions.IsParamsArray(Phx.Symbols.ParameterSymbol)">
            <summary>
            Determines if the specified parameter is a params array parameter.
            </summary>
            <param name="parameterSymbol">The ParameterSymbol to be tested.</param>
            <returns>'true' if the specified parameter is a params array parameter.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParameterSymbolExtensions.HasAttribute(Phx.Symbols.ParameterSymbol,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>Returns true if the named attribute is applied to this Symbol.</summary>
            <param name="symbol">Symbol whose attributes are to be searched.</param>
            <param name="attributeType">A reference to the type of the attribute.</param>
            <returns>True if the named attribute is applied to this Symbol.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParameterSymbolExtensions.GetAttribute(Phx.Symbols.ParameterSymbol,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>Get the attribute on this symbol that matches the specified type.</summary>
            <param name="symbol">Symbol whose attribute are to be searched.</param>
            <param name="attributeType">Type reference to the type of the attribute.</param>
            <returns>The first matching AttributeSymbol, or null if none are found.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParameterSymbolExtensions.GetAttributes(Phx.Symbols.ParameterSymbol,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>Finds all the attributes on this symbol that match the specified type.</summary>
            <param name="symbol">Symbol whose attribute are to be searched.</param>
            <param name="attributeType">Type reference to the type of the attribute.</param>
            <returns>List of the matching AttributeSymbols. List is empty if none are found.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParameterSymbolExtensions.IsRefOrOutParameter(Phx.Symbols.ParameterSymbol)">
            <summary>
            Returns true if this <see cref="T:Phx.Symbols.ParameterSymbol"/> is a ref or out parameter.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParameterSymbolExtensions.GetUserDefinedParameterIndex(Phx.Symbols.ParameterSymbol)">
            <summary>
            Gets the 0 based index of the parameter.
            </summary>
            <returns>Index of the parameter or -1 if the parameter is not found.</returns>
            <remarks>Reasons the parameter might not be found could be that it is this pointer or it if is not user defined.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParameterSymbolsExtensions">
            <summary>
            Helper methods for the Phx.Symbols.ParameterSymbols type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParameterSymbolsExtensions.AsList(Phx.Symbols.ParameterSymbols)">
            <summary>
            Get a list of the ParameterSymbol objects in a ParameterSymbols collection.
            </summary>
            <param name="parameterSymbols">The ParameterSymbols collection.</param>
            <returns>A list of the ParameterSymbol objects in the specified collection.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParsedFormatString">
            <summary>
            Represents a parsed format string used by methods such as System.String.Format.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParsedFormatString.ToString">
            <summary>
            Return a human-readable string representation of the format string.
            </summary>
            <returns>A human-readable string representation of the format string.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParsedFormatString.TryParse(System.String)">
            <summary>
            Try to parse a format string.
            </summary>
            <param name="format">The format string to be parsed.</param>
            <returns>A ParsedFormatString object representing the parsed format string, or null if the
            format string could not be parsed.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParsedFormatString.TryParse(System.String,System.Int32@)">
            <summary>
            Try to parse a format string.
            </summary>
            <param name="format">The format string to be parsed.</param>
            <param name="invalidCharacterIndex">Set to the index of the first invalid character in the format string, or
            -1 if the format string is parsed successfully.</param>
            <returns>A ParsedFormatString object representing the parsed format string, or null if the
            format string could not be parsed.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParsedFormatString.FixedText">
            <summary>
            List of the fixed text segments in this format string.
            </summary>
            <remarks>The number of fixed text segments is always one greater than the number of format items.  A fixed text segment may consist of an empty
            string.</remarks>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.ParsedFormatString.FormatItems">
            <summary>
            List of the format items in this format string.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.PointerTypeReference">
            <summary>
            Represents a reference to a pointer type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.PointerTypeReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>
            Create a new PointerTypeReference object.
            </summary>
            <param name="referentType">Type reference for the type to which this pointer points.</param>
            <remarks>The pointer is assumed to be an ObjectPointer (e.g. "System.String ^").</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.PointerTypeReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,Phx.Types.PointerTypeKind)">
            <summary>
            Create a new PointerTypeReference object
            </summary>
            <param name="referentType">Type reference for the type to which this pointer points.</param>
            <param name="pointerTypeKind">Kind of pointer.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.PointerTypeReference.MatchesType(Phx.Types.Type)">
            <summary>
            Determine if this type reference refers to the specified Phoenix type
            </summary>
            <param name="type">Phoenix type to compare to this type reference.</param>
            <returns>'true' if this type reference refers to the specified type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.PointerTypeReference.ToString">
            <summary>
            String representation of the TypeReference.
            </summary>
            <remarks>This is used for debugging only.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.PropertySymbolExtensions">
            <summary>
            Helper methods for the Phx.Symbols.PropertySymbol type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.PropertySymbolExtensions.GetParameters(Phx.Symbols.PropertySymbol)">
            <summary>Returns an IList of Phx.Symbols.FunctionArguments that represent the extra parameters this property takes.
            In other words this returns the parameters a property takes minus the value parameter all properties take.</summary>
            <param name="propertySymbol"></param>
            <returns>Returns an IList of Phx.Symbols.FunctionArguments that represent the extra parameters this property takes.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.PropertySymbolExtensions.IsIndexer(Phx.Symbols.PropertySymbol)">
            <summary>
            Returns true if this PropertySymbol represents an indexer.
            </summary>
            <param name="propertySymbol"></param>
            <returns>Returns whether or not this PropertySymbol is an indexer.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SpecificGenericArgumentListReference">
            <summary>
            Represents a reference to a CLR generic argument list with specific argument types.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SpecificGenericArgumentListReference.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference[])">
            <summary>
            Create a new SpecificGenericArgumentListReference object.
            </summary>
            <param name="argumentTypes">The types of the generic arguments.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SpecificGenericArgumentListReference.MatchesArgumentList(Phx.Collections.Generic.List{Phx.Types.Type})">
            <summary>
            Determine if this generic argument list reference refers to the specified Phoenix generic argument list.
            </summary>
            <param name="typeList">Phoenix TypeList to compare to this generic argument list reference.</param>
            <returns>'true' if this generic argument list reference refers to the specified argument list.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SpecificGenericArgumentListReference.ToString">
            <summary>
            String representation of the GenericArgumentListReference.
            </summary>
            <remarks>This is used for debugging only.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SpecificMethodSignatureReference">
            <summary>
            Represents a reference to a CLR method signature with specific parameter types.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SpecificMethodSignatureReference.#ctor(System.Boolean,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference[])">
            <summary>
            Create a new SpecificMethodSignatureReference object.
            </summary>
            <param name="isInstanceMethod">'true' if the method is an instance method, 'false' if it is a static method.</param>
            <param name="returnType">The return type of the method.  This may be null to indicate that the method returns void.</param>
            <param name="parameterTypes">The types of the parameters of the method (not including the 'this' parameter).</param>
            <remarks>The calling convention is assumed to be ClrCall.</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SpecificMethodSignatureReference.#ctor(Phx.Types.CallingConventionKind,System.Boolean,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference[])">
            <summary>
            Create a new SpecificMethodSignatureReference object.
            </summary>
            <param name="callingConvention">The calling convention of the method.</param>
            <param name="isInstanceMethod">'true' if the method is an instance method, 'false' if it is a static method.</param>
            <param name="returnType">The return type of the method.  This may be null to indicate that the method returns void.</param>
            <param name="parameterTypes">The types of the parameters of the method (not including the 'this' parameter).</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SpecificMethodSignatureReference.#ctor(Phx.Types.CallingConventionKind,System.Boolean,System.Int32,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference[])">
            <summary>
            Create a new SpecificMethodSignatureReference object.
            </summary>
            <param name="callingConvention">The calling convention of the method.</param>
            <param name="isInstanceMethod">'true' if the method is an instance method, 'false' if it is a static method.</param>
            <param name="genericArity">The number of generic arguments the method has (the generic arity).</param>
            <param name="returnType">The return type of the method.  This may be null to indicate that the method returns void.</param>
            <param name="parameterTypes">The types of the parameters of the method (not including the 'this' parameter).</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SpecificMethodSignatureReference.MatchesFunctionType(Phx.Types.FunctionType)">
            <summary>
            Determine if this method signature reference refers to the specified Phoenix function type.
            </summary>
            <param name="functionType">Phoenix FunctionType to compare to this method signature reference.</param>
            <returns>'true' if this method signature reference refers to the specified FunctionType.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SpecificMethodSignatureReference.ToString">
            <summary>
            String representation of the MethodSignatureReference.
            </summary>
            <remarks>This is used for debugging only.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.StaticFieldSymbolExtensions">
            <summary>
            Extension methods for use with Phoenix static field symbols.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.StaticFieldSymbolExtensions.IsCompilerGenerated(Phx.Symbols.StaticFieldSymbol)">
            <summary>
            Return true if the specified static field symbol is marked as compiler generated.
            </summary>
            <param name="staticFieldSymbol">The static field symbol to test.</param>
            <returns>'true' if <paramref name="staticFieldSymbol"/> is compiler generated.</returns>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SymbolExtensions">
            <summary>
            Extension methods for use with Phoenix symbols.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SymbolExtensions.HasAttribute(Phx.Symbols.Symbol,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>Returns true if the named attribute is applied to this Symbol.</summary>
            <param name="symbol">Symbol whose attributes are to be searched.</param>
            <param name="attributeType">A reference to the type of the attribute.</param>
            <returns>True if the named attribute is applied to this Symbol.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SymbolExtensions.HasAttribute(Phx.Collections.Generic.List{Phx.Symbols.AttributeSymbol},Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>Returns true if at least one attribute matching the specified type is present in the list.</summary>
            <param name="attributeList">List of attributes to be searched.</param>
            <param name="attributeType">A reference to the type of the attribute.</param>
            <returns>True if an attribute matching the specified type is present in the list.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SymbolExtensions.GetAttribute(Phx.Collections.Generic.List{Phx.Symbols.AttributeSymbol},Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>Get the attribute that matches the specified type.</summary>
            <param name="attributeList">List of attributes to be searched.</param>
            <param name="attributeType">Type reference to the type of the attribute.</param>
            <returns>The first matching AttributeSymbol, or null if none are found.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SymbolExtensions.GetAttributes(Phx.Collections.Generic.List{Phx.Symbols.AttributeSymbol},Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>Finds all the attributes that match the specified type.</summary>
            <param name="attributeList">List of attributes to be searched.</param>
            <param name="attributeType">Type reference to the type of the attribute.</param>
            <returns>List of the matching AttributeSymbols. List is empty if none are found.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SymbolExtensions.GetAttribute(Phx.Symbols.Symbol,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>Get the attribute on this symbol that matches the specified type.</summary>
            <param name="symbol">Symbol whose attribute are to be searched.</param>
            <param name="attributeType">Type reference to the type of the attribute.</param>
            <returns>The first matching AttributeSymbol, or null if none are found.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SymbolExtensions.GetAttributes(Phx.Symbols.Symbol,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference)">
            <summary>Finds all the attributes on this symbol that match the specified type.</summary>
            <param name="symbol">Symbol whose attribute are to be searched.</param>
            <param name="attributeType">Type reference to the type of the attribute.</param>
            <returns>List of the matching AttributeSymbols. List is empty if none are found.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.SymbolExtensions.IsVisibleOutsideAssembly(Phx.Symbols.Symbol)">
            <summary>
            Determine if the specified symbol is visible outside the assembly that contains it.
            </summary>
            <param name="symbol">The symbol to test.</param>
            <returns>'true' if the symbol can be referenced from another assembly, 'false' otherwise.</returns>
            <remarks>This method returns 'false' for any symbol that is only visible to a friend assembly.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReferenceDictionary`1">
            <summary>
            Dictionary that maps from Type to a user-specified value.  The dictionary is populated using
            TypeReference objects as the keys, but lookup is done using Type objects as the keys.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReferenceDictionary`1.#ctor">
            <summary>
            Create a new TypeReferenceDictionary.
            </summary>
            <remarks>The default value for any type not in the dictionary is assumed to be default(TValue).</remarks>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReferenceDictionary`1.#ctor(`0)">
            <summary>
            Create a new TypeReferenceDictionary.
            </summary>
            <param name="defaultValue">The default value to be returned when looking up a type that is not in the dictionary.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReferenceDictionary`1.Add(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReference,`0)">
            <summary>
            Add a mapping from a TypeReference to a user-specified value.
            </summary>
            <param name="methodReference">Reference to the type to use as a key.</param>
            <param name="value">User-specified value to map the type to.</param>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeReferenceDictionary`1.Item(Phx.Types.Type)">
            <summary>
            Gets the value associated with a specified type.
            </summary>
            <param name="type">Type for which the value is to be retrieved.</param>
            <returns>The value associated with the specified type.  If the type is not found, the return value is the
            default value specified in the constructor.</returns>
            <remarks>If more than one key matches this type, one of the matching values will be returned,
            but it is undefined which one is actually returned.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeVariableTypeExtensions">
            <summary>
            Helper methods for the Phx.Types.TypeVariableType type.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeVariableTypeExtensions.GetConstraints(Phx.Types.TypeVariableType)">
            <summary>
            Returns a collection of all the constraints applied to this type variable.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeVariableTypeExtensions.IsReferenceTypeVariable(Phx.Types.TypeVariableType)">
            <summary>
            Returns true if this type variable is constrained to be a reference type.
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.AggregateTypeVisitor">
            <summary>
            Visits all of the aggregate types referenced by a type
            </summary>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeVariableTypeReference">
            <summary>
            A reference to a CLR type that will match a specific type variable.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeVariableTypeReference.#ctor(System.Boolean,System.Int32)">
            <summary>
            Create a new TypeVariableTypeReference.
            </summary>
            <param name="isFunctionParameter">'true' if the reference should match a generic function parameter, 'false' if it should match a generic type parameter.</param>
            <param name="index">Zero-based index of the parameter to match.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeVariableTypeReference.MatchesType(Phx.Types.Type)">
            <summary>
            Determine if the specified Phoenix type refers to or derives from this type reference.
            </summary>
            <param name="type">Phoenix type to compare.</param>
            <returns>'true' if the specified type is a TypeVariableType that matchines this reference.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.TypeVariableTypeReference.ToString">
            <summary>
            String representation of the TypeVariableTypeReference.
            </summary>
            <remarks>This is used for debugging only.</remarks>
        </member>
        <member name="T:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter">
            <summary>
            An expression formatter for rendering Phoenix expressions as Visual Basic source code.
            </summary>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.GetDisplayName(Microsoft.VisualStudio.CodeAnalysis.AnalysisResults.Keyword)">
            <summary>
            Gets the display name for the specified <see cref="T:Microsoft.VisualStudio.CodeAnalysis.AnalysisResults.Keyword"/>
            </summary>
            <param name="keyword">The keyword to get the display name for.</param>
            <returns>The display name of <paramref name="keyword"/></returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.GetDisplayName(Phx.ExtensibleObject)">
            <summary>
            Gets the display name for the specified <see cref="T:Phx.ExtensibleObject"/>
            </summary>
            <param name="node">The Phoenix object to get the display name for.</param>
            <returns><paramref name="node"/>'s display name.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.#ctor(Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedParamArrayAnalysis,Microsoft.VisualStudio.CodeAnalysis.Phoenix.Dataflow.SharedCopyAnalysis)">
            <summary>
            Primary constructor for a CSharpExpressionFormatter.
            </summary>
            <param name="paramArrayAnalysis">SharedParamArrayAnalysis to use for extracting individual arguments from a parameters array.</param>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.FormatCall(Phx.IR.CallInstruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a method call.
            </summary>
            <param name="callInstruction">The call to format.</param>
            <param name="useType">The type that the destination of <paramref name="callInstruction"/> had when it it was used.</param>
            <param name="definitionType">The type that <paramref name="callInstruction"/> results in.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted method call.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.FormatIsInst(Phx.IR.Instruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats an isinst instruction as a use of the 'TryCast' operator.
            </summary>
            <param name="instruction">The isinst instruction to format.</param>
            <param name="useType">The type that the variable argument to IsInst had when it it was used.</param>
            <param name="definitionType">The original type that the variable argument to IsInst was defined with.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>"TryCast([var], [type])" where [var] is the variable be cast, and [type] is the destination type</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.FormatCast(Phx.IR.Operand,Phx.Types.Type,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)" -->
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.FormatConversionOperator(Phx.IR.CallInstruction,Phx.Types.Type,Phx.Types.Type@,System.IFormatProvider)">
            <summary>
            Formats a conversion from one type to another.
            </summary>
            <param name="callInstruction">The instruction that contains the convert operation.</param>
            <param name="useType">The type that the variable argument to the conversion had when it it was used.</param>
            <param name="definitionType">The original type that that the variable argument to the conversion was defined with.</param>
            <param name="formatProvider">An IFormatProvider to use in formatting the expression.</param>
            <returns>The formatted type conversion.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.FormatFloatLiteral(System.Double,Phx.Types.Type,System.IFormatProvider)">
            <summary>
            Formats a floating point literal.
            </summary>
            <param name="value">The value to format.</param>
            <param name="type">The type of the literal.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>The string representation of the float.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.FormatCharacterLiteral(System.Char,System.IFormatProvider)">
            <summary>
            Formats a character literal.
            </summary>
            <param name="immediateOperand">The immediate to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>The string represenation of the character.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.FormatCharacterLiteral(System.Char,System.IFormatProvider,System.Boolean@)">
            <summary>
            Formats a character literal.
            </summary>
            <param name="ch">The character to format</param>
            <param name="formatProvider">The IFormatProvider to use when formatting.</param>
            <returns>The string representation of the character.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.FormatStringLiteral(System.String,System.IFormatProvider)">
            <summary>
            Formats a string immediate.
            </summary>
            <param name="literal">The string literal to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>The escaped and formatted version of <paramref name="literal"/>.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.FormatDefaultValueOfValueType(Phx.Types.AggregateType,System.IFormatProvider)">
            <summary>
            Format the default value of a value type.
            </summary>
            <param name="aggregateType">The value type to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>A string representation of the default value of the value type.</returns>
        </member>
        <member name="M:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.FormatDefaultValueOfTypeVariable(Phx.Types.TypeVariableType,System.IFormatProvider)">
            <summary>
            Format the default value of a type variable type.
            </summary>
            <param name="type">The type variable type to format.</param>
            <param name="formatProvider">An IFormatProvider to use when formatting.</param>
            <returns>A string representation of the default value of the type variable type.</returns>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.ArrayPrefix">
            <summary>
            Gets the string to use for prefixing an array.  "[" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.ArraySuffix">
            <summary>
            Gets the string to use for suffixing an array.  "]" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.BitwiseOrOperator">
            <summary>
            Gets the string to use to represent a bitwise OR operation.  "|" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.ClassSeparator">
            <summary>
            Gets the string to use for seperating the namespace name from the class name, 
            or the class name from a static method name.  "::" in C++.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.PointerAccess">
            <summary>
            Gets the string to use for seperating the class name from an instance method name
            when accessed through a pointer.  "->" in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.ReferenceAccess">
            <summary>
            Gets the string to use for seperating the class name from an instance method name
            when accessed through a reference.  "." in C#.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.ManagedPointerDefinitionSymbol">
            <summary>
            Gets the string to use for declaring a managed pointer.  "^" in C++.
            </summary>
        </member>
        <member name="P:Microsoft.VisualStudio.CodeAnalysis.Phoenix.Utilities.VisualBasicExpressionFormatter.StringConcatOperator">
            <summary>
            Gets the string to use to represent a string concatenation operation.  "+" in C#.
            </summary>
        </member>
    </members>
</doc>
